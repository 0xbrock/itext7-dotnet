/*
* $Id: a9372285e8e28efed51548f9f0e25bfce672a415 $
*
* This file is part of the iText (R) project.
* Copyright (c) 2014-2015 iText Group NV
* Authors: Bruno Lowagie, Paulo Soares, et al.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License version 3
* as published by the Free Software Foundation with the addition of the
* following permission added to Section 15 as permitted in Section 7(a):
* FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
* ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
* OF THIRD PARTY RIGHTS
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE.
* See the GNU Affero General Public License for more details.
* You should have received a copy of the GNU Affero General Public License
* along with this program; if not, see http://www.gnu.org/licenses or write to
* the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA, 02110-1301 USA, or download the license from the following URL:
* http://itextpdf.com/terms-of-use/
*
* The interactive user interfaces in modified source and object code versions
* of this program must display Appropriate Legal Notices, as required under
* Section 5 of the GNU Affero General Public License.
*
* In accordance with Section 7(b) of the GNU Affero General Public License,
* a covered work must retain the producer line in every PDF that is created
* or manipulated using iText.
*
* You can be released from the requirements of the license by purchasing
* a commercial license. Buying such a license is mandatory as soon as you
* develop commercial activities involving the iText software without
* disclosing the source code of your own applications.
* These activities include: offering paid services to customers as an ASP,
* serving PDFs on the fly in a web application, shipping iText with a closed
* source product.
*
* For more information, please contact iText Software Corp. at this
* address: sales@itextpdf.com
*
*
* This class is based on the C# open source freeware library Clipper:
* http://www.angusj.com/delphi/clipper.php
* The original classes were distributed under the Boost Software License:
*
* Freeware for both open source and commercial applications
* Copyright 2010-2014 Angus Johnson
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
using System;
using System.Collections.Generic;

namespace com.itextpdf.kernel.pdf.canvas.parser.clipper
{
	/// <summary>A pure convenience class to avoid writing List<IntPoint> everywhere.</summary>
	/// <author>Tobias Mahlmann</author>
	public class Path : List<Point.LongPoint>
	{
		internal class Join
		{
			internal Path.OutPt outPt1;

			internal Path.OutPt outPt2;

			private Point.LongPoint offPt;

			public virtual Point.LongPoint GetOffPt()
			{
				return offPt;
			}

			public virtual void SetOffPt(Point.LongPoint offPt)
			{
				this.offPt = offPt;
			}
		}

		internal class OutPt
		{
			public static Path.OutRec GetLowerMostRec(Path.OutRec outRec1, Path.OutRec outRec2
				)
			{
				//work out which polygon fragment has the correct hole state ...
				if (outRec1.bottomPt == null)
				{
					outRec1.bottomPt = outRec1.pts.GetBottomPt();
				}
				if (outRec2.bottomPt == null)
				{
					outRec2.bottomPt = outRec2.pts.GetBottomPt();
				}
				Path.OutPt bPt1 = outRec1.bottomPt;
				Path.OutPt bPt2 = outRec2.bottomPt;
				if (bPt1.GetPt().GetY() > bPt2.GetPt().GetY())
				{
					return outRec1;
				}
				else
				{
					if (bPt1.GetPt().GetY() < bPt2.GetPt().GetY())
					{
						return outRec2;
					}
					else
					{
						if (bPt1.GetPt().GetX() < bPt2.GetPt().GetX())
						{
							return outRec1;
						}
						else
						{
							if (bPt1.GetPt().GetX() > bPt2.GetPt().GetX())
							{
								return outRec2;
							}
							else
							{
								if (bPt1.next == bPt1)
								{
									return outRec2;
								}
								else
								{
									if (bPt2.next == bPt2)
									{
										return outRec1;
									}
									else
									{
										if (IsFirstBottomPt(bPt1, bPt2))
										{
											return outRec1;
										}
										else
										{
											return outRec2;
										}
									}
								}
							}
						}
					}
				}
			}

			private static bool IsFirstBottomPt(Path.OutPt btmPt1, Path.OutPt btmPt2)
			{
				Path.OutPt p = btmPt1.prev;
				while (p.GetPt().Equals(btmPt1.GetPt()) && !p.Equals(btmPt1))
				{
					p = p.prev;
				}
				double dx1p = Math.Abs(Point.LongPoint.GetDeltaX(btmPt1.GetPt(), p.GetPt()));
				p = btmPt1.next;
				while (p.GetPt().Equals(btmPt1.GetPt()) && !p.Equals(btmPt1))
				{
					p = p.next;
				}
				double dx1n = Math.Abs(Point.LongPoint.GetDeltaX(btmPt1.GetPt(), p.GetPt()));
				p = btmPt2.prev;
				while (p.GetPt().Equals(btmPt2.GetPt()) && !p.Equals(btmPt2))
				{
					p = p.prev;
				}
				double dx2p = Math.Abs(Point.LongPoint.GetDeltaX(btmPt2.GetPt(), p.GetPt()));
				p = btmPt2.next;
				while (p.GetPt().Equals(btmPt2.GetPt()) && p.Equals(btmPt2))
				{
					p = p.next;
				}
				double dx2n = Math.Abs(Point.LongPoint.GetDeltaX(btmPt2.GetPt(), p.GetPt()));
				return dx1p >= dx2p && dx1p >= dx2n || dx1n >= dx2p && dx1n >= dx2n;
			}

			internal int idx;

			protected internal Point.LongPoint pt;

			internal Path.OutPt next;

			internal Path.OutPt prev;

			public virtual Path.OutPt Duplicate(bool InsertAfter)
			{
				Path.OutPt result = new Path.OutPt();
				result.SetPt(new Point.LongPoint(GetPt()));
				result.idx = idx;
				if (InsertAfter)
				{
					result.next = next;
					result.prev = this;
					next.prev = result;
					next = result;
				}
				else
				{
					result.prev = prev;
					result.next = this;
					prev.next = result;
					prev = result;
				}
				return result;
			}

			internal virtual Path.OutPt GetBottomPt()
			{
				Path.OutPt dups = null;
				Path.OutPt p = next;
				Path.OutPt pp = this;
				while (p != pp)
				{
					if (p.GetPt().GetY() > pp.GetPt().GetY())
					{
						pp = p;
						dups = null;
					}
					else
					{
						if (p.GetPt().GetY() == pp.GetPt().GetY() && p.GetPt().GetX() <= pp.GetPt().GetX(
							))
						{
							if (p.GetPt().GetX() < pp.GetPt().GetX())
							{
								dups = null;
								pp = p;
							}
							else
							{
								if (p.next != pp && p.prev != pp)
								{
									dups = p;
								}
							}
						}
					}
					p = p.next;
				}
				if (dups != null)
				{
					//there appears to be at least 2 vertices at bottomPt so ...
					while (dups != p)
					{
						if (!IsFirstBottomPt(p, dups))
						{
							pp = dups;
						}
						dups = dups.next;
						while (!dups.GetPt().Equals(pp.GetPt()))
						{
							dups = dups.next;
						}
					}
				}
				return pp;
			}

			public virtual int GetPointCount()
			{
				int result = 0;
				Path.OutPt p = this;
				do
				{
					result++;
					p = p.next;
				}
				while (p != this && p != null);
				return result;
			}

			public virtual Point.LongPoint GetPt()
			{
				return pt;
			}

			public virtual void ReversePolyPtLinks()
			{
				Path.OutPt pp1;
				Path.OutPt pp2;
				pp1 = this;
				do
				{
					pp2 = pp1.next;
					pp1.next = pp1.prev;
					pp1.prev = pp2;
					pp1 = pp2;
				}
				while (pp1 != this);
			}

			public virtual void SetPt(Point.LongPoint pt)
			{
				this.pt = pt;
			}
		}

		protected internal class Maxima
		{
			protected internal long X;

			protected internal Path.Maxima Next;

			protected internal Path.Maxima Prev;
		}

		internal class OutRec
		{
			internal int Idx;

			internal bool isHole;

			internal bool isOpen;

			internal Path.OutRec firstLeft;

			protected internal Path.OutPt pts;

			internal Path.OutPt bottomPt;

			internal PolyNode polyNode;

			//see comments in clipper.pas
			public virtual double Area()
			{
				Path.OutPt op = pts;
				if (op == null)
				{
					return 0;
				}
				double a = 0;
				do
				{
					a = a + (double)(op.prev.GetPt().GetX() + op.GetPt().GetX()) * (double)(op.prev.GetPt
						().GetY() - op.GetPt().GetY());
					op = op.next;
				}
				while (op != pts);
				return a * 0.5;
			}

			public virtual void FixHoleLinkage()
			{
				//skip if an outermost polygon or
				//already already points to the correct FirstLeft ...
				if (firstLeft == null || isHole != firstLeft.isHole && firstLeft.pts != null)
				{
					return;
				}
				Path.OutRec orfl = firstLeft;
				while (orfl != null && (orfl.isHole == isHole || orfl.pts == null))
				{
					orfl = orfl.firstLeft;
				}
				firstLeft = orfl;
			}

			public virtual Path.OutPt GetPoints()
			{
				return pts;
			}

			public virtual void SetPoints(Path.OutPt pts)
			{
				this.pts = pts;
			}
		}

		private static Path.OutPt ExcludeOp(Path.OutPt op)
		{
			Path.OutPt result = op.prev;
			result.next = op.next;
			op.next.prev = result;
			result.idx = 0;
			return result;
		}

		private const long serialVersionUID = -7120161578077546673L;

		public Path()
			: base()
		{
		}

		public Path(Point.LongPoint[] points)
			: this()
		{
			foreach (Point.LongPoint point in points)
			{
				Add(point);
			}
		}

		public Path(int cnt)
			: base(cnt)
		{
		}

		public Path(ICollection<Point.LongPoint> c)
			: base(c)
		{
		}

		public virtual double Area()
		{
			int cnt = Count;
			if (cnt < 3)
			{
				return 0;
			}
			double a = 0;
			for (int i = 0; i < cnt; ++i)
			{
				a += ((double)this[j].GetX() + this[i].GetX()) * ((double)this[j].GetY() - this[i
					].GetY());
				j = i;
			}
			return -a * 0.5;
		}

		public virtual Path CleanPolygon()
		{
			return CleanPolygon(1.415);
		}

		public virtual Path CleanPolygon(double distance)
		{
			//distance = proximity in units/pixels below which vertices will be stripped.
			//Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have
			//both x & y coords within 1 unit, then the second vertex will be stripped.
			int cnt = Count;
			if (cnt == 0)
			{
				return new Path();
			}
			Path.OutPt[] outPts = new Path.OutPt[cnt];
			for (int i = 0; i < cnt; ++i)
			{
				outPts[i] = new Path.OutPt();
			}
			for (int i_1 = 0; i_1 < cnt; ++i_1)
			{
				outPts[i_1].pt = this[i_1];
				outPts[i_1].next = outPts[(i_1 + 1) % cnt];
				outPts[i_1].next.prev = outPts[i_1];
				outPts[i_1].idx = 0;
			}
			double distSqrd = distance * distance;
			Path.OutPt op = outPts[0];
			while (op.idx == 0 && op.next != op.prev)
			{
				if (Point.ArePointsClose(op.pt, op.prev.pt, distSqrd))
				{
					op = ExcludeOp(op);
					cnt--;
				}
				else
				{
					if (Point.ArePointsClose(op.prev.pt, op.next.pt, distSqrd))
					{
						ExcludeOp(op.next);
						op = ExcludeOp(op);
						cnt -= 2;
					}
					else
					{
						if (Point.SlopesNearCollinear(op.prev.pt, op.pt, op.next.pt, distSqrd))
						{
							op = ExcludeOp(op);
							cnt--;
						}
						else
						{
							op.idx = 1;
							op = op.next;
						}
					}
				}
			}
			if (cnt < 3)
			{
				cnt = 0;
			}
			Path result = new Path(cnt);
			for (int i_2 = 0; i_2 < cnt; ++i_2)
			{
				result.Add(op.pt);
				op = op.next;
			}
			outPts = null;
			return result;
		}

		public virtual int IsPointInPolygon(Point.LongPoint pt)
		{
			//returns 0 if false, +1 if true, -1 if pt ON polygon boundary
			//See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
			//http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
			int result = 0;
			int cnt = Count;
			if (cnt < 3)
			{
				return 0;
			}
			Point.LongPoint ip = this[0];
			for (int i = 1; i <= cnt; ++i)
			{
				Point.LongPoint ipNext = i == cnt ? this[0] : this[i];
				if (ipNext.GetY() == pt.GetY())
				{
					if (ipNext.GetX() == pt.GetX() || ip.GetY() == pt.GetY() && ipNext.GetX() > pt.GetX
						() == ip.GetX() < pt.GetX())
					{
						return -1;
					}
				}
				if (ip.GetY() < pt.GetY() != ipNext.GetY() < pt.GetY())
				{
					if (ip.GetX() >= pt.GetX())
					{
						if (ipNext.GetX() > pt.GetX())
						{
							result = 1 - result;
						}
						else
						{
							double d = (double)(ip.GetX() - pt.GetX()) * (ipNext.GetY() - pt.GetY()) - (double
								)(ipNext.GetX() - pt.GetX()) * (ip.GetY() - pt.GetY());
							if (d == 0)
							{
								return -1;
							}
							else
							{
								if (d > 0 == ipNext.GetY() > ip.GetY())
								{
									result = 1 - result;
								}
							}
						}
					}
					else
					{
						if (ipNext.GetX() > pt.GetX())
						{
							double d = (double)(ip.GetX() - pt.GetX()) * (ipNext.GetY() - pt.GetY()) - (double
								)(ipNext.GetX() - pt.GetX()) * (ip.GetY() - pt.GetY());
							if (d == 0)
							{
								return -1;
							}
							else
							{
								if (d > 0 == ipNext.GetY() > ip.GetY())
								{
									result = 1 - result;
								}
							}
						}
					}
				}
				ip = ipNext;
			}
			return result;
		}

		public virtual bool Orientation()
		{
			return Area() >= 0;
		}

		public virtual void Reverse()
		{
			java.util.Collections.Reverse(this);
		}

		public virtual Path TranslatePath(Point.LongPoint delta)
		{
			Path outPath = new Path(Count);
			for (int i = 0; i < Count; i++)
			{
				outPath.Add(new Point.LongPoint(this[i].GetX() + delta.GetX(), this[i].GetY() + delta
					.GetY()));
			}
			return outPath;
		}
	}
}
