/*
* $Id: 62d7b46dac59f33accc94952ebd58334c6bd288e $
*
* This file is part of the iText (R) project.
* Copyright (c) 2014-2015 iText Group NV
* Authors: Bruno Lowagie, Paulo Soares, et al.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License version 3
* as published by the Free Software Foundation with the addition of the
* following permission added to Section 15 as permitted in Section 7(a):
* FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
* ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
* OF THIRD PARTY RIGHTS
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE.
* See the GNU Affero General Public License for more details.
* You should have received a copy of the GNU Affero General Public License
* along with this program; if not, see http://www.gnu.org/licenses or write to
* the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA, 02110-1301 USA, or download the license from the following URL:
* http://itextpdf.com/terms-of-use/
*
* The interactive user interfaces in modified source and object code versions
* of this program must display Appropriate Legal Notices, as required under
* Section 5 of the GNU Affero General Public License.
*
* In accordance with Section 7(b) of the GNU Affero General Public License,
* a covered work must retain the producer line in every PDF that is created
* or manipulated using iText.
*
* You can be released from the requirements of the license by purchasing
* a commercial license. Buying such a license is mandatory as soon as you
* develop commercial activities involving the iText software without
* disclosing the source code of your own applications.
* These activities include: offering paid services to customers as an ASP,
* serving PDFs on the fly in a web application, shipping iText with a closed
* source product.
*
* For more information, please contact iText Software Corp. at this
* address: sales@itextpdf.com
*
*
* This class is based on the C# open source freeware library Clipper:
* http://www.angusj.com/delphi/clipper.php
* The original classes were distributed under the Boost Software License:
*
* Freeware for both open source and commercial applications
* Copyright 2010-2014 Angus Johnson
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
using System;
using java.math;
using java.util.logging;

namespace com.itextpdf.kernel.pdf.canvas.parser.clipper
{
	internal class Edge
	{
		internal enum Side
		{
			LEFT,
			RIGHT
		}

		internal static bool DoesE2InsertBeforeE1(com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge
			 e1, com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge e2)
		{
			if (e2.current.GetX() == e1.current.GetX())
			{
				if (e2.top.GetY() > e1.top.GetY())
				{
					return e2.top.GetX() < TopX(e1, e2.top.GetY());
				}
				else
				{
					return e1.top.GetX() > TopX(e2, e1.top.GetY());
				}
			}
			else
			{
				return e2.current.GetX() < e1.current.GetX();
			}
		}

		internal static bool SlopesEqual(com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge
			 e1, com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge e2, bool useFullRange)
		{
			if (useFullRange)
			{
				return BigInteger.ValueOf(e1.GetDelta().GetY()).Multiply(BigInteger.ValueOf(e2.GetDelta
					().GetX())).Equals(BigInteger.ValueOf(e1.GetDelta().GetX()).Multiply(BigInteger.
					ValueOf(e2.GetDelta().GetY())));
			}
			else
			{
				return (e1.GetDelta().GetY()) * (e2.GetDelta().GetX()) == (e1.GetDelta().GetX()) 
					* (e2.GetDelta().GetY());
			}
		}

		internal static void SwapPolyIndexes(com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge
			 edge1, com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge edge2)
		{
			int outIdx = edge1.outIdx;
			edge1.outIdx = edge2.outIdx;
			edge2.outIdx = outIdx;
		}

		internal static void SwapSides(com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge
			 edge1, com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge edge2)
		{
			Edge.Side side = edge1.side;
			edge1.side = edge2.side;
			edge2.side = side;
		}

		internal static long TopX(com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge edge
			, long currentY)
		{
			if (currentY == edge.GetTop().GetY())
			{
				return edge.GetTop().GetX();
			}
			return (edge.GetBot().GetX() + Math.Round(edge.deltaX * (currentY - edge.GetBot()
				.GetY())));
		}

		private readonly Point.LongPoint bot;

		private readonly Point.LongPoint current;

		private readonly Point.LongPoint top;

		private readonly Point.LongPoint delta;

		internal double deltaX;

		internal Clipper.PolyType polyTyp;

		internal Edge.Side side;

		internal int windDelta;

		internal int windCnt;

		internal int windCnt2;

		internal int outIdx;

		internal com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge next;

		internal com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge prev;

		internal com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge nextInLML;

		internal com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge nextInAEL;

		internal com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge prevInAEL;

		internal com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge nextInSEL;

		internal com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge prevInSEL;

		protected internal const int SKIP = -2;

		protected internal const int UNASSIGNED = -1;

		protected internal const double HORIZONTAL = -3.4E+38;

		private static readonly Logger LOGGER = Logger.GetLogger(typeof(com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge
			).GetName());

		public Edge()
		{
			//1 or -1 depending on winding direction
			//winding count of the opposite polytype
			delta = new Point.LongPoint();
			top = new Point.LongPoint();
			bot = new Point.LongPoint();
			current = new Point.LongPoint();
		}

		public virtual com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge FindNextLocMin(
			)
		{
			com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge e = this;
			com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge e2;
			for (; ; )
			{
				while (!e.bot.Equals(e.prev.bot) || e.current.Equals(e.top))
				{
					e = e.next;
				}
				if (e.deltaX != com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge.HORIZONTAL && 
					e.prev.deltaX != com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge.HORIZONTAL)
				{
					break;
				}
				while (e.prev.deltaX == com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge.HORIZONTAL
					)
				{
					e = e.prev;
				}
				e2 = e;
				while (e.deltaX == com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge.HORIZONTAL)
				{
					e = e.next;
				}
				if (e.top.GetY() == e.prev.bot.GetY())
				{
					continue;
				}
				//ie just an intermediate horz.
				if (e2.prev.bot.GetX() < e.bot.GetX())
				{
					e = e2;
				}
				break;
			}
			return e;
		}

		public virtual Point.LongPoint GetBot()
		{
			return bot;
		}

		public virtual Point.LongPoint GetCurrent()
		{
			return current;
		}

		public virtual Point.LongPoint GetDelta()
		{
			return delta;
		}

		public virtual com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge GetMaximaPair()
		{
			com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge result = null;
			if (next.top.Equals(top) && next.nextInLML == null)
			{
				result = next;
			}
			else
			{
				if (prev.top.Equals(top) && prev.nextInLML == null)
				{
					result = prev;
				}
			}
			if (result != null && (result.outIdx == com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge
				.SKIP || result.nextInAEL == result.prevInAEL && !result.IsHorizontal()))
			{
				return null;
			}
			return result;
		}

		public virtual com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge GetNextInAEL(Clipper.Direction
			 direction)
		{
			return direction == Clipper.Direction.LEFT_TO_RIGHT ? nextInAEL : prevInAEL;
		}

		public virtual Point.LongPoint GetTop()
		{
			return top;
		}

		public virtual bool IsContributing(Clipper.PolyFillType clipFillType, Clipper.PolyFillType
			 subjFillType, Clipper.ClipType clipType)
		{
			LOGGER.Entering(typeof(com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge).GetName
				(), "isContributing");
			Clipper.PolyFillType pft;
			Clipper.PolyFillType pft2;
			if (polyTyp == Clipper.PolyType.SUBJECT)
			{
				pft = subjFillType;
				pft2 = clipFillType;
			}
			else
			{
				pft = clipFillType;
				pft2 = subjFillType;
			}
			switch (pft)
			{
				case Clipper.PolyFillType.EVEN_ODD:
				{
					//return false if a subj line has been flagged as inside a subj polygon
					if (windDelta == 0 && windCnt != 1)
					{
						return false;
					}
					break;
				}

				case Clipper.PolyFillType.NON_ZERO:
				{
					if (Math.Abs(windCnt) != 1)
					{
						return false;
					}
					break;
				}

				case Clipper.PolyFillType.POSITIVE:
				{
					if (windCnt != 1)
					{
						return false;
					}
					break;
				}

				default:
				{
					//PolyFillType.pftNegative
					if (windCnt != -1)
					{
						return false;
					}
					break;
				}
			}
			switch (clipType)
			{
				case Clipper.ClipType.INTERSECTION:
				{
					switch (pft2)
					{
						case Clipper.PolyFillType.EVEN_ODD:
						case Clipper.PolyFillType.NON_ZERO:
						{
							return windCnt2 != 0;
						}

						case Clipper.PolyFillType.POSITIVE:
						{
							return windCnt2 > 0;
						}

						default:
						{
							return windCnt2 < 0;
						}
					}
					goto case Clipper.ClipType.UNION;
				}

				case Clipper.ClipType.UNION:
				{
					switch (pft2)
					{
						case Clipper.PolyFillType.EVEN_ODD:
						case Clipper.PolyFillType.NON_ZERO:
						{
							return windCnt2 == 0;
						}

						case Clipper.PolyFillType.POSITIVE:
						{
							return windCnt2 <= 0;
						}

						default:
						{
							return windCnt2 >= 0;
						}
					}
					goto case Clipper.ClipType.DIFFERENCE;
				}

				case Clipper.ClipType.DIFFERENCE:
				{
					if (polyTyp == Clipper.PolyType.SUBJECT)
					{
						switch (pft2)
						{
							case Clipper.PolyFillType.EVEN_ODD:
							case Clipper.PolyFillType.NON_ZERO:
							{
								return windCnt2 == 0;
							}

							case Clipper.PolyFillType.POSITIVE:
							{
								return windCnt2 <= 0;
							}

							default:
							{
								return windCnt2 >= 0;
							}
						}
					}
					else
					{
						switch (pft2)
						{
							case Clipper.PolyFillType.EVEN_ODD:
							case Clipper.PolyFillType.NON_ZERO:
							{
								return windCnt2 != 0;
							}

							case Clipper.PolyFillType.POSITIVE:
							{
								return windCnt2 > 0;
							}

							default:
							{
								return windCnt2 < 0;
							}
						}
					}
					goto case Clipper.ClipType.XOR;
				}

				case Clipper.ClipType.XOR:
				{
					if (windDelta == 0)
					{
						switch (pft2)
						{
							case Clipper.PolyFillType.EVEN_ODD:
							case Clipper.PolyFillType.NON_ZERO:
							{
								return windCnt2 == 0;
							}

							case Clipper.PolyFillType.POSITIVE:
							{
								return windCnt2 <= 0;
							}

							default:
							{
								return windCnt2 >= 0;
							}
						}
					}
					else
					{
						return true;
					}
					break;
				}
			}
			return true;
		}

		public virtual bool IsEvenOddAltFillType(Clipper.PolyFillType clipFillType, Clipper.PolyFillType
			 subjFillType)
		{
			if (polyTyp == Clipper.PolyType.SUBJECT)
			{
				return clipFillType == Clipper.PolyFillType.EVEN_ODD;
			}
			else
			{
				return subjFillType == Clipper.PolyFillType.EVEN_ODD;
			}
		}

		public virtual bool IsEvenOddFillType(Clipper.PolyFillType clipFillType, Clipper.PolyFillType
			 subjFillType)
		{
			if (polyTyp == Clipper.PolyType.SUBJECT)
			{
				return subjFillType == Clipper.PolyFillType.EVEN_ODD;
			}
			else
			{
				return clipFillType == Clipper.PolyFillType.EVEN_ODD;
			}
		}

		public virtual bool IsHorizontal()
		{
			return delta.GetY() == 0;
		}

		public virtual bool IsIntermediate(double y)
		{
			return top.GetY() == y && nextInLML != null;
		}

		public virtual bool IsMaxima(double Y)
		{
			return top.GetY() == Y && nextInLML == null;
		}

		public virtual void ReverseHorizontal()
		{
			//swap horizontal edges' top and bottom x's so they follow the natural
			//progression of the bounds - ie so their xbots will align with the
			//adjoining lower edge. [Helpful in the ProcessHorizontal() method.]
			long temp = top.GetX();
			top.SetX(bot.GetX());
			bot.SetX(temp);
			temp = top.GetZ();
			top.SetZ(bot.GetZ());
			bot.SetZ(temp);
		}

		public virtual void SetBot(Point.LongPoint bot)
		{
			this.bot.Set(bot);
		}

		public virtual void SetCurrent(Point.LongPoint current)
		{
			this.current.Set(current);
		}

		public virtual void SetTop(Point.LongPoint top)
		{
			this.top.Set(top);
		}

		public override String ToString()
		{
			return "TEdge [Bot=" + bot + ", Curr=" + current + ", Top=" + top + ", Delta=" + 
				delta + ", Dx=" + deltaX + ", PolyTyp=" + polyTyp + ", Side=" + side + ", WindDelta="
				 + windDelta + ", WindCnt=" + windCnt + ", WindCnt2=" + windCnt2 + ", OutIdx=" +
				 outIdx + ", Next=" + next + ", Prev=" + prev + ", NextInLML=" + nextInLML + ", NextInAEL="
				 + nextInAEL + ", PrevInAEL=" + prevInAEL + ", NextInSEL=" + nextInSEL + ", PrevInSEL="
				 + prevInSEL + "]";
		}

		public virtual void UpdateDeltaX()
		{
			delta.SetX(top.GetX() - bot.GetX());
			delta.SetY(top.GetY() - bot.GetY());
			if (delta.GetY() == 0)
			{
				deltaX = com.itextpdf.kernel.pdf.canvas.parser.clipper.Edge.HORIZONTAL;
			}
			else
			{
				deltaX = (double)delta.GetX() / delta.GetY();
			}
		}
	}
}
