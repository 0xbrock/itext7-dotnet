/*
* $Id: d4599152b27f0e29b63cf3a196a80bb3d661572a $
*
* This file is part of the iText (R) project.
* Copyright (c) 2014-2015 iText Group NV
* Authors: Bruno Lowagie, Paulo Soares, et al.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License version 3
* as published by the Free Software Foundation with the addition of the
* following permission added to Section 15 as permitted in Section 7(a):
* FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
* ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
* OF THIRD PARTY RIGHTS
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE.
* See the GNU Affero General Public License for more details.
* You should have received a copy of the GNU Affero General Public License
* along with this program; if not, see http://www.gnu.org/licenses or write to
* the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA, 02110-1301 USA, or download the license from the following URL:
* http://itextpdf.com/terms-of-use/
*
* The interactive user interfaces in modified source and object code versions
* of this program must display Appropriate Legal Notices, as required under
* Section 5 of the GNU Affero General Public License.
*
* In accordance with Section 7(b) of the GNU Affero General Public License,
* a covered work must retain the producer line in every PDF that is created
* or manipulated using iText.
*
* You can be released from the requirements of the license by purchasing
* a commercial license. Buying such a license is mandatory as soon as you
* develop commercial activities involving the iText software without
* disclosing the source code of your own applications.
* These activities include: offering paid services to customers as an ASP,
* serving PDFs on the fly in a web application, shipping iText with a closed
* source product.
*
* For more information, please contact iText Software Corp. at this
* address: sales@itextpdf.com
*
*
* This class is based on the C# open source freeware library Clipper:
* http://www.angusj.com/delphi/clipper.php
* The original classes were distributed under the Boost Software License:
*
* Freeware for both open source and commercial applications
* Copyright 2010-2014 Angus Johnson
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
using System;
using java.lang;
using java.math;

namespace com.itextpdf.kernel.pdf.canvas.parser.clipper
{
	public abstract class Point<T>
		where T : Number
	{
		public class DoublePoint : Point<Double>
		{
			public DoublePoint()
				: this(0, 0)
			{
			}

			public DoublePoint(double x, double y)
				: this(x, y, 0)
			{
			}

			public DoublePoint(double x, double y, double z)
				: base(x, y, z)
			{
			}

			public DoublePoint(Point.DoublePoint other)
				: base(other)
			{
			}

			public virtual double GetX()
			{
				return x;
			}

			public virtual double GetY()
			{
				return y;
			}

			public virtual double GetZ()
			{
				return z;
			}
		}

		public class LongPoint : Point<long>
		{
			public static double GetDeltaX(Point.LongPoint pt1, Point.LongPoint pt2)
			{
				if (pt1.GetY() == pt2.GetY())
				{
					return Edge.HORIZONTAL;
				}
				else
				{
					return (double)(pt2.GetX() - pt1.GetX()) / (pt2.GetY() - pt1.GetY());
				}
			}

			public LongPoint()
				: this(0, 0)
			{
			}

			public LongPoint(long x, long y)
				: this(x, y, 0)
			{
			}

			public LongPoint(double x, double y)
				: this((long)x, (long)y)
			{
			}

			public LongPoint(long x, long y, long z)
				: base(x, y, z)
			{
			}

			public LongPoint(Point.LongPoint other)
				: base(other)
			{
			}

			public virtual long GetX()
			{
				return x;
			}

			public virtual long GetY()
			{
				return y;
			}

			public virtual long GetZ()
			{
				return z;
			}
		}

		private class NumberComparator<T> : Comparator<T>
			where T : Number
		{
			/// <exception cref="System.InvalidCastException"/>
			public virtual int Compare(T a, T b)
			{
				return a.CompareTo(b);
			}
		}

		internal static bool ArePointsClose<_T0, _T1>(Point<_T0> pt1, Point<_T1> pt2, double
			 distSqrd)
			where _T0 : Number
			where _T1 : Number
		{
			double dx = pt1.x - pt2.x;
			double dy = pt1.y - pt2.y;
			return dx * dx + dy * dy <= distSqrd;
		}

		internal static double DistanceFromLineSqrd<_T0, _T1, _T2>(Point<_T0> pt, Point<_T1
			> ln1, Point<_T2> ln2)
			where _T0 : Number
			where _T1 : Number
			where _T2 : Number
		{
			//The equation of a line in general form (Ax + By + C = 0)
			//given 2 points (x�,y�) & (x�,y�) is ...
			//(y� - y�)x + (x� - x�)y + (y� - y�)x� - (x� - x�)y� = 0
			//A = (y� - y�); B = (x� - x�); C = (y� - y�)x� - (x� - x�)y�
			//perpendicular distance of point (x�,y�) = (Ax� + By� + C)/Sqrt(A� + B�)
			//see http://en.wikipedia.org/wiki/Perpendicular_distance
			double A = ln1.y - ln2.y;
			double B = ln2.x - ln1.x;
			double C = A * ln1.x + B * ln1.y;
			C = A * pt.x + B * pt.y - C;
			return C * C / (A * A + B * B);
		}

		internal static Point.DoublePoint GetUnitNormal(Point.LongPoint pt1, Point.LongPoint
			 pt2)
		{
			double dx = pt2.x - pt1.x;
			double dy = pt2.y - pt1.y;
			if (dx == 0 && dy == 0)
			{
				return new Point.DoublePoint();
			}
			double f = 1 * 1.0 / Math.Sqrt(dx * dx + dy * dy);
			dx *= f;
			dy *= f;
			return new Point.DoublePoint(dy, -dx);
		}

		protected internal static bool IsPt2BetweenPt1AndPt3(Point.LongPoint pt1, Point.LongPoint
			 pt2, Point.LongPoint pt3)
		{
			if (pt1.Equals(pt3) || pt1.Equals(pt2) || pt3.Equals(pt2))
			{
				return false;
			}
			else
			{
				if (pt1.x != pt3.x)
				{
					return pt2.x > pt1.x == pt2.x < pt3.x;
				}
				else
				{
					return pt2.y > pt1.y == pt2.y < pt3.y;
				}
			}
		}

		protected internal static bool SlopesEqual(Point.LongPoint pt1, Point.LongPoint pt2
			, Point.LongPoint pt3, bool useFullRange)
		{
			if (useFullRange)
			{
				return BigInteger.ValueOf(pt1.GetY() - pt2.GetY()).Multiply(BigInteger.ValueOf(pt2
					.GetX() - pt3.GetX())).Equals(BigInteger.ValueOf(pt1.GetX() - pt2.GetX()).Multiply
					(BigInteger.ValueOf(pt2.GetY() - pt3.GetY())));
			}
			else
			{
				return (pt1.GetY() - pt2.GetY()) * (pt2.GetX() - pt3.GetX()) - (pt1.GetX() - pt2.
					GetX()) * (pt2.GetY() - pt3.GetY()) == 0;
			}
		}

		protected internal static bool SlopesEqual(Point.LongPoint pt1, Point.LongPoint pt2
			, Point.LongPoint pt3, Point.LongPoint pt4, bool useFullRange)
		{
			if (useFullRange)
			{
				return BigInteger.ValueOf(pt1.GetY() - pt2.GetY()).Multiply(BigInteger.ValueOf(pt3
					.GetX() - pt4.GetX())).Equals(BigInteger.ValueOf(pt1.GetX() - pt2.GetX()).Multiply
					(BigInteger.ValueOf(pt3.GetY() - pt4.GetY())));
			}
			else
			{
				return (pt1.GetY() - pt2.GetY()) * (pt3.GetX() - pt4.GetX()) - (pt1.GetX() - pt2.
					GetX()) * (pt3.GetY() - pt4.GetY()) == 0;
			}
		}

		internal static bool SlopesNearCollinear(Point.LongPoint pt1, Point.LongPoint pt2
			, Point.LongPoint pt3, double distSqrd)
		{
			//this function is more accurate when the point that's GEOMETRICALLY
			//between the other 2 points is the one that's tested for distance.
			//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts
			if (Math.Abs(pt1.x - pt2.x) > Math.Abs(pt1.y - pt2.y))
			{
				if (pt1.x > pt2.x == pt1.x < pt3.x)
				{
					return DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;
				}
				else
				{
					if (pt2.x > pt1.x == pt2.x < pt3.x)
					{
						return DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
					}
					else
					{
						return DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;
					}
				}
			}
			else
			{
				if (pt1.y > pt2.y == pt1.y < pt3.y)
				{
					return DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;
				}
				else
				{
					if (pt2.y > pt1.y == pt2.y < pt3.y)
					{
						return DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
					}
					else
					{
						return DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;
					}
				}
			}
		}

		private static readonly Point.NumberComparator NUMBER_COMPARATOR = new Point.NumberComparator
			();

		protected internal T x;

		protected internal T y;

		protected internal T z;

		protected internal Point(Point<T> pt)
			: this(pt.x, pt.y, pt.z)
		{
		}

		protected internal Point(T x, T y, T z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public override bool Equals(Object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is Point<object>)
			{
				Point<object> a = (Point<object>)obj;
				return NUMBER_COMPARATOR.Compare(x, a.x) == 0 && NUMBER_COMPARATOR.Compare(y, a.y
					) == 0;
			}
			else
			{
				return false;
			}
		}

		public virtual void Set(Point<T> other)
		{
			x = other.x;
			y = other.y;
			z = other.z;
		}

		public virtual void SetX(T x)
		{
			this.x = x;
		}

		public virtual void SetY(T y)
		{
			this.y = y;
		}

		public virtual void SetZ(T z)
		{
			this.z = z;
		}

		public override String ToString()
		{
			return "Point [x=" + x + ", y=" + y + ", z=" + z + "]";
		}
		// end struct IntPoint
	}
}
