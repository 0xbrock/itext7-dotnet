/*
* $Id: 68ce5a84a4c88520b2b626df4f2866f3ddacdb32 $
*
* This file is part of the iText (R) project.
* Copyright (c) 2014-2015 iText Group NV
* Authors: Bruno Lowagie, Paulo Soares, et al.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License version 3
* as published by the Free Software Foundation with the addition of the
* following permission added to Section 15 as permitted in Section 7(a):
* FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
* ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
* OF THIRD PARTY RIGHTS
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE.
* See the GNU Affero General Public License for more details.
* You should have received a copy of the GNU Affero General Public License
* along with this program; if not, see http://www.gnu.org/licenses or write to
* the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA, 02110-1301 USA, or download the license from the following URL:
* http://itextpdf.com/terms-of-use/
*
* The interactive user interfaces in modified source and object code versions
* of this program must display Appropriate Legal Notices, as required under
* Section 5 of the GNU Affero General Public License.
*
* In accordance with Section 7(b) of the GNU Affero General Public License,
* a covered work must retain the producer line in every PDF that is created
* or manipulated using iText.
*
* You can be released from the requirements of the license by purchasing
* a commercial license. Buying such a license is mandatory as soon as you
* develop commercial activities involving the iText software without
* disclosing the source code of your own applications.
* These activities include: offering paid services to customers as an ASP,
* serving PDFs on the fly in a web application, shipping iText with a closed
* source product.
*
* For more information, please contact iText Software Corp. at this
* address: sales@itextpdf.com
*
*
* This class is based on the C# open source freeware library Clipper:
* http://www.angusj.com/delphi/clipper.php
* The original classes were distributed under the Boost Software License:
*
* Freeware for both open source and commercial applications
* Copyright 2010-2014 Angus Johnson
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
using System;
using System.Collections.Generic;

namespace com.itextpdf.kernel.pdf.canvas.parser.clipper
{
	public class ClipperOffset
	{
		private static bool NearZero(double val)
		{
			return val > -TOLERANCE && val < TOLERANCE;
		}

		private Paths destPolys;

		private Path srcPoly;

		private Path destPoly;

		private readonly IList<Point.DoublePoint> normals;

		private double delta;

		private double inA;

		private double sin;

		private double cos;

		private double miterLim;

		private double stepsPerRad;

		private Point.LongPoint lowest;

		private readonly PolyNode polyNodes;

		private readonly double arcTolerance;

		private readonly double miterLimit;

		private const double TWO_PI = Math.PI * 2;

		private const double DEFAULT_ARC_TOLERANCE = 0.25;

		private const double TOLERANCE = 1.0E-20;

		public ClipperOffset()
			: this(2, DEFAULT_ARC_TOLERANCE)
		{
		}

		public ClipperOffset(double miterLimit)
			: this(miterLimit, DEFAULT_ARC_TOLERANCE)
		{
		}

		public ClipperOffset(double miterLimit, double arcTolerance)
		{
			this.miterLimit = miterLimit;
			this.arcTolerance = arcTolerance;
			lowest = new Point.LongPoint();
			lowest.SetX(-1l);
			polyNodes = new PolyNode();
			normals = new List<Point.DoublePoint>();
		}

		public virtual void AddPath(Path path, IClipper.JoinType joinType, IClipper.EndType
			 endType)
		{
			int highI = path.Count - 1;
			if (highI < 0)
			{
				return;
			}
			PolyNode newNode = new PolyNode();
			newNode.SetJoinType(joinType);
			newNode.SetEndType(endType);
			//strip duplicate points from path and also get index to the lowest point ...
			if (endType == IClipper.EndType.CLOSED_LINE || endType == IClipper.EndType.CLOSED_POLYGON)
			{
				while (highI > 0 && path[0] == path[highI])
				{
					highI--;
				}
			}
			newNode.GetPolygon().Add(path[0]);
			int j = 0;
			int k = 0;
			for (int i = 1; i <= highI; i++)
			{
				if (newNode.GetPolygon()[j] != path[i])
				{
					j++;
					newNode.GetPolygon().Add(path[i]);
					if (path[i].GetY() > newNode.GetPolygon()[k].GetY() || path[i].GetY() == newNode.
						GetPolygon()[k].GetY() && path[i].GetX() < newNode.GetPolygon()[k].GetX())
					{
						k = j;
					}
				}
			}
			if (endType == IClipper.EndType.CLOSED_POLYGON && j < 2)
			{
				return;
			}
			polyNodes.AddChild(newNode);
			//if this path's lowest pt is lower than all the others then update m_lowest
			if (endType != IClipper.EndType.CLOSED_POLYGON)
			{
				return;
			}
			if (lowest.GetX() < 0)
			{
				lowest = new Point.LongPoint(polyNodes.GetChildCount() - 1, k);
			}
			else
			{
				Point.LongPoint ip = polyNodes.GetChilds()[(int)lowest.GetX()].GetPolygon()[(int)
					lowest.GetY()];
				if (newNode.GetPolygon()[k].GetY() > ip.GetY() || newNode.GetPolygon()[k].GetY() 
					== ip.GetY() && newNode.GetPolygon()[k].GetX() < ip.GetX())
				{
					lowest = new Point.LongPoint(polyNodes.GetChildCount() - 1, k);
				}
			}
		}

		public virtual void AddPaths(Paths paths, IClipper.JoinType joinType, IClipper.EndType
			 endType)
		{
			foreach (Path p in paths)
			{
				AddPath(p, joinType, endType);
			}
		}

		public virtual void Clear()
		{
			polyNodes.GetChilds().Clear();
			lowest.SetX(-1l);
		}

		private void DoMiter(int j, int k, double r)
		{
			double q = delta / r;
			destPoly.Add(new Point.LongPoint(Math.Round(srcPoly[j].GetX() + (normals[k].GetX(
				) + normals[j].GetX()) * q), Math.Round(srcPoly[j].GetY() + (normals[k].GetY() +
				 normals[j].GetY()) * q)));
		}

		private void DoOffset(double delta)
		{
			destPolys = new Paths();
			this.delta = delta;
			//if Zero offset, just copy any CLOSED polygons to m_p and return ...
			if (NearZero(delta))
			{
				for (int i = 0; i < polyNodes.GetChildCount(); i++)
				{
					PolyNode node = polyNodes.GetChilds()[i];
					if (node.GetEndType() == IClipper.EndType.CLOSED_POLYGON)
					{
						destPolys.Add(node.GetPolygon());
					}
				}
				return;
			}
			//see offset_triginometry3.svg in the documentation folder ...
			if (miterLimit > 2)
			{
				miterLim = 2 / (miterLimit * miterLimit);
			}
			else
			{
				miterLim = 0.5;
			}
			double y;
			if (arcTolerance <= 0.0)
			{
				y = DEFAULT_ARC_TOLERANCE;
			}
			else
			{
				if (arcTolerance > Math.Abs(delta) * DEFAULT_ARC_TOLERANCE)
				{
					y = Math.Abs(delta) * DEFAULT_ARC_TOLERANCE;
				}
				else
				{
					y = arcTolerance;
				}
			}
			//see offset_triginometry2.svg in the documentation folder ...
			double steps = Math.PI / Math.Acos(1 - y / Math.Abs(delta));
			sin = Math.Sin(TWO_PI / steps);
			cos = Math.Cos(TWO_PI / steps);
			stepsPerRad = steps / TWO_PI;
			if (delta < 0.0)
			{
				sin = -sin;
			}
			for (int i_1 = 0; i_1 < polyNodes.GetChildCount(); i_1++)
			{
				PolyNode node = polyNodes.GetChilds()[i_1];
				srcPoly = node.GetPolygon();
				int len = srcPoly.Count;
				if (len == 0 || (delta <= 0 && (len < 3 || node.GetEndType() != IClipper.EndType.
					CLOSED_POLYGON)))
				{
					continue;
				}
				destPoly = new Path();
				if (len == 1)
				{
					if (node.GetJoinType() == IClipper.JoinType.ROUND)
					{
						double X = 1.0;
						double Y = 0.0;
						for (int j = 1; j <= steps; j++)
						{
							destPoly.Add(new Point.LongPoint(Math.Round(srcPoly[0].GetX() + X * delta), Math.
								Round(srcPoly[0].GetY() + Y * delta)));
							double X2 = X;
							X = X * cos - sin * Y;
							Y = X2 * sin + Y * cos;
						}
					}
					else
					{
						double X = -1.0;
						double Y = -1.0;
						for (int j = 0; j < 4; ++j)
						{
							destPoly.Add(new Point.LongPoint(Math.Round(srcPoly[0].GetX() + X * delta), Math.
								Round(srcPoly[0].GetY() + Y * delta)));
							if (X < 0)
							{
								X = 1;
							}
							else
							{
								if (Y < 0)
								{
									Y = 1;
								}
								else
								{
									X = -1;
								}
							}
						}
					}
					destPolys.Add(destPoly);
					continue;
				}
				//build m_normals ...
				normals.Clear();
				for (int j_1 = 0; j_1 < len - 1; j_1++)
				{
					normals.Add(Point.GetUnitNormal(srcPoly[j_1], srcPoly[j_1 + 1]));
				}
				if (node.GetEndType() == IClipper.EndType.CLOSED_LINE || node.GetEndType() == IClipper.EndType
					.CLOSED_POLYGON)
				{
					normals.Add(Point.GetUnitNormal(srcPoly[len - 1], srcPoly[0]));
				}
				else
				{
					normals.Add(new Point.DoublePoint(normals[len - 2]));
				}
				if (node.GetEndType() == IClipper.EndType.CLOSED_POLYGON)
				{
					int[] k = new int[] { len - 1 };
					for (int j = 0; j_1 < len; j_1++)
					{
						OffsetPoint(j_1, k, node.GetJoinType());
					}
					destPolys.Add(destPoly);
				}
				else
				{
					if (node.GetEndType() == IClipper.EndType.CLOSED_LINE)
					{
						int[] k = new int[] { len - 1 };
						for (int j = 0; j_1 < len; j_1++)
						{
							OffsetPoint(j_1, k, node.GetJoinType());
						}
						destPolys.Add(destPoly);
						destPoly = new Path();
						//re-build m_normals ...
						Point.DoublePoint n = normals[len - 1];
						for (int j_2 = len - 1; j_2 > 0; j_2--)
						{
							normals[j_2] = new Point.DoublePoint(-normals[j_2 - 1].GetX(), -normals[j_2 - 1].
								GetY());
						}
						normals[0] = new Point.DoublePoint(-n.GetX(), -n.GetY(), 0);
						k[0] = 0;
						for (int j_3 = len - 1; j_3 >= 0; j_3--)
						{
							OffsetPoint(j_3, k, node.GetJoinType());
						}
						destPolys.Add(destPoly);
					}
					else
					{
						int[] k = new int[1];
						for (int j = 1; j_1 < len - 1; ++j_1)
						{
							OffsetPoint(j_1, k, node.GetJoinType());
						}
						Point.LongPoint pt1;
						if (node.GetEndType() == IClipper.EndType.OPEN_BUTT)
						{
							int j_2 = len - 1;
							pt1 = new Point.LongPoint(Math.Round(srcPoly[j_2].GetX() + normals[j_2].GetX() * 
								delta), Math.Round(srcPoly[j_2].GetY() + normals[j_2].GetY() * delta), 0);
							destPoly.Add(pt1);
							pt1 = new Point.LongPoint(Math.Round(srcPoly[j_2].GetX() - normals[j_2].GetX() * 
								delta), Math.Round(srcPoly[j_2].GetY() - normals[j_2].GetY() * delta), 0);
							destPoly.Add(pt1);
						}
						else
						{
							int j_2 = len - 1;
							k[0] = len - 2;
							inA = 0;
							normals[j_2] = new Point.DoublePoint(-normals[j_2].GetX(), -normals[j_2].GetY());
							if (node.GetEndType() == IClipper.EndType.OPEN_SQUARE)
							{
								DoSquare(j_2, k[0], true);
							}
							else
							{
								DoRound(j_2, k[0]);
							}
						}
						//re-build m_normals ...
						for (int j_3 = len - 1; j_3 > 0; j_3--)
						{
							normals[j_3] = new Point.DoublePoint(-normals[j_3 - 1].GetX(), -normals[j_3 - 1].
								GetY());
						}
						normals[0] = new Point.DoublePoint(-normals[1].GetX(), -normals[1].GetY());
						k[0] = len - 1;
						for (int j_4 = k[0] - 1; j_4 > 0; --j_4)
						{
							OffsetPoint(j_4, k, node.GetJoinType());
						}
						if (node.GetEndType() == IClipper.EndType.OPEN_BUTT)
						{
							pt1 = new Point.LongPoint(Math.Round(srcPoly[0].GetX() - normals[0].GetX() * delta
								), Math.Round(srcPoly[0].GetY() - normals[0].GetY() * delta));
							destPoly.Add(pt1);
							pt1 = new Point.LongPoint(Math.Round(srcPoly[0].GetX() + normals[0].GetX() * delta
								), Math.Round(srcPoly[0].GetY() + normals[0].GetY() * delta));
							destPoly.Add(pt1);
						}
						else
						{
							k[0] = 1;
							inA = 0;
							if (node.GetEndType() == IClipper.EndType.OPEN_SQUARE)
							{
								DoSquare(0, 1, true);
							}
							else
							{
								DoRound(0, 1);
							}
						}
						destPolys.Add(destPoly);
					}
				}
			}
		}

		private void DoRound(int j, int k)
		{
			double a = Math.Atan2(inA, normals[k].GetX() * normals[j].GetX() + normals[k].GetY
				() * normals[j].GetY());
			int steps = Math.Max((int)Math.Round(stepsPerRad * Math.Abs(a)), 1);
			double X = normals[k].GetX();
			double Y = normals[k].GetY();
			double X2;
			for (int i = 0; i < steps; ++i)
			{
				destPoly.Add(new Point.LongPoint(Math.Round(srcPoly[j].GetX() + X * delta), Math.
					Round(srcPoly[j].GetY() + Y * delta)));
				X2 = X;
				X = X * cos - sin * Y;
				Y = X2 * sin + Y * cos;
			}
			destPoly.Add(new Point.LongPoint(Math.Round(srcPoly[j].GetX() + normals[j].GetX()
				 * delta), Math.Round(srcPoly[j].GetY() + normals[j].GetY() * delta)));
		}

		private void DoSquare(int j, int k, bool addExtra)
		{
			double nkx = normals[k].GetX();
			double nky = normals[k].GetY();
			double njx = normals[j].GetX();
			double njy = normals[j].GetY();
			double sjx = srcPoly[j].GetX();
			double sjy = srcPoly[j].GetY();
			double dx = Math.Tan(Math.Atan2(inA, nkx * njx + nky * njy) / 4);
			destPoly.Add(new Point.LongPoint(Math.Round(sjx + delta * (nkx - (addExtra ? nky 
				* dx : 0))), Math.Round(sjy + delta * (nky + (addExtra ? nkx * dx : 0))), 0));
			destPoly.Add(new Point.LongPoint(Math.Round(sjx + delta * (njx + (addExtra ? njy 
				* dx : 0))), Math.Round(sjy + delta * (njy - (addExtra ? njx * dx : 0))), 0));
		}

		//------------------------------------------------------------------------------
		public virtual void Execute(Paths solution, double delta)
		{
			solution.Clear();
			FixOrientations();
			DoOffset(delta);
			//now clean up 'corners' ...
			DefaultClipper clpr = new DefaultClipper(IClipper.REVERSE_SOLUTION);
			clpr.AddPaths(destPolys, IClipper.PolyType.SUBJECT, true);
			if (delta > 0)
			{
				clpr.Execute(IClipper.ClipType.UNION, solution, IClipper.PolyFillType.POSITIVE, IClipper.PolyFillType
					.POSITIVE);
			}
			else
			{
				LongRect r = destPolys.GetBounds();
				Path outer = new Path(4);
				outer.Add(new Point.LongPoint(r.left - 10, r.bottom + 10, 0));
				outer.Add(new Point.LongPoint(r.right + 10, r.bottom + 10, 0));
				outer.Add(new Point.LongPoint(r.right + 10, r.top - 10, 0));
				outer.Add(new Point.LongPoint(r.left - 10, r.top - 10, 0));
				clpr.AddPath(outer, IClipper.PolyType.SUBJECT, true);
				clpr.Execute(IClipper.ClipType.UNION, solution, IClipper.PolyFillType.NEGATIVE, IClipper.PolyFillType
					.NEGATIVE);
				if (solution.Count > 0)
				{
					solution.RemoveAt(0);
				}
			}
		}

		//------------------------------------------------------------------------------
		public virtual void Execute(PolyTree solution, double delta)
		{
			solution.Clear();
			FixOrientations();
			DoOffset(delta);
			//now clean up 'corners' ...
			DefaultClipper clpr = new DefaultClipper(IClipper.REVERSE_SOLUTION);
			clpr.AddPaths(destPolys, IClipper.PolyType.SUBJECT, true);
			if (delta > 0)
			{
				clpr.Execute(IClipper.ClipType.UNION, solution, IClipper.PolyFillType.POSITIVE, IClipper.PolyFillType
					.POSITIVE);
			}
			else
			{
				LongRect r = destPolys.GetBounds();
				Path outer = new Path(4);
				outer.Add(new Point.LongPoint(r.left - 10, r.bottom + 10, 0));
				outer.Add(new Point.LongPoint(r.right + 10, r.bottom + 10, 0));
				outer.Add(new Point.LongPoint(r.right + 10, r.top - 10, 0));
				outer.Add(new Point.LongPoint(r.left - 10, r.top - 10, 0));
				clpr.AddPath(outer, IClipper.PolyType.SUBJECT, true);
				clpr.Execute(IClipper.ClipType.UNION, solution, IClipper.PolyFillType.NEGATIVE, IClipper.PolyFillType
					.NEGATIVE);
				//remove the outer PolyNode rectangle ...
				if (solution.GetChildCount() == 1 && solution.GetChilds()[0].GetChildCount() > 0)
				{
					PolyNode outerNode = solution.GetChilds()[0];
					solution.GetChilds()[0] = outerNode.GetChilds()[0];
					solution.GetChilds()[0].SetParent(solution);
					for (int i = 1; i < outerNode.GetChildCount(); i++)
					{
						solution.AddChild(outerNode.GetChilds()[i]);
					}
				}
				else
				{
					solution.Clear();
				}
			}
		}

		//------------------------------------------------------------------------------
		private void FixOrientations()
		{
			//fixup orientations of all closed paths if the orientation of the
			//closed path with the lowermost vertex is wrong ...
			if (lowest.GetX() >= 0 && !polyNodes.childs[(int)lowest.GetX()].GetPolygon().Orientation
				())
			{
				for (int i = 0; i < polyNodes.GetChildCount(); i++)
				{
					PolyNode node = polyNodes.childs[i];
					if (node.GetEndType() == IClipper.EndType.CLOSED_POLYGON || node.GetEndType() == 
						IClipper.EndType.CLOSED_LINE && node.GetPolygon().Orientation())
					{
						java.util.Collections.Reverse(node.GetPolygon());
					}
				}
			}
			else
			{
				for (int i = 0; i < polyNodes.GetChildCount(); i++)
				{
					PolyNode node = polyNodes.childs[i];
					if (node.GetEndType() == IClipper.EndType.CLOSED_LINE && !node.GetPolygon().Orientation
						())
					{
						java.util.Collections.Reverse(node.GetPolygon());
					}
				}
			}
		}

		private void OffsetPoint(int j, int[] kV, IClipper.JoinType jointype)
		{
			//cross product ...
			int k = kV[0];
			double nkx = normals[k].GetX();
			double nky = normals[k].GetY();
			double njy = normals[j].GetY();
			double njx = normals[j].GetX();
			long sjx = srcPoly[j].GetX();
			long sjy = srcPoly[j].GetY();
			inA = nkx * njy - njx * nky;
			if (Math.Abs(inA * delta) < 1.0)
			{
				//dot product ...
				double cosA = nkx * njx + njy * nky;
				if (cosA > 0)
				{
					// angle ==> 0 degrees
					destPoly.Add(new Point.LongPoint(Math.Round(sjx + nkx * delta), Math.Round(sjy + 
						nky * delta), 0));
					return;
				}
			}
			else
			{
				//else angle ==> 180 degrees
				if (inA > 1.0)
				{
					inA = 1.0;
				}
				else
				{
					if (inA < -1.0)
					{
						inA = -1.0;
					}
				}
			}
			if (inA * delta < 0)
			{
				destPoly.Add(new Point.LongPoint(Math.Round(sjx + nkx * delta), Math.Round(sjy + 
					nky * delta)));
				destPoly.Add(srcPoly[j]);
				destPoly.Add(new Point.LongPoint(Math.Round(sjx + njx * delta), Math.Round(sjy + 
					njy * delta)));
			}
			else
			{
				switch (jointype)
				{
					case IClipper.JoinType.MITER:
					{
						double r = 1 + njx * nkx + njy * nky;
						if (r >= miterLim)
						{
							DoMiter(j, k, r);
						}
						else
						{
							DoSquare(j, k, false);
						}
						break;
					}

					case IClipper.JoinType.BEVEL:
					{
						DoSquare(j, k, false);
						break;
					}

					case IClipper.JoinType.ROUND:
					{
						DoRound(j, k);
						break;
					}
				}
			}
			kV[0] = j;
		}
		//------------------------------------------------------------------------------
	}
}
