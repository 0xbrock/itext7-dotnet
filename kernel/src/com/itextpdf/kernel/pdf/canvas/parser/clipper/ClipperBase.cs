/*
* $Id: 4f71558adacde358cc40486fb268c73817e09b6b $
*
* This file is part of the iText (R) project.
* Copyright (c) 2014-2015 iText Group NV
* Authors: Bruno Lowagie, Paulo Soares, et al.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License version 3
* as published by the Free Software Foundation with the addition of the
* following permission added to Section 15 as permitted in Section 7(a):
* FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
* ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
* OF THIRD PARTY RIGHTS
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE.
* See the GNU Affero General Public License for more details.
* You should have received a copy of the GNU Affero General Public License
* along with this program; if not, see http://www.gnu.org/licenses or write to
* the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA, 02110-1301 USA, or download the license from the following URL:
* http://itextpdf.com/terms-of-use/
*
* The interactive user interfaces in modified source and object code versions
* of this program must display Appropriate Legal Notices, as required under
* Section 5 of the GNU Affero General Public License.
*
* In accordance with Section 7(b) of the GNU Affero General Public License,
* a covered work must retain the producer line in every PDF that is created
* or manipulated using iText.
*
* You can be released from the requirements of the license by purchasing
* a commercial license. Buying such a license is mandatory as soon as you
* develop commercial activities involving the iText software without
* disclosing the source code of your own applications.
* These activities include: offering paid services to customers as an ASP,
* serving PDFs on the fly in a web application, shipping iText with a closed
* source product.
*
* For more information, please contact iText Software Corp. at this
* address: sales@itextpdf.com
*
*
* This class is based on the C# open source freeware library Clipper:
* http://www.angusj.com/delphi/clipper.php
* The original classes were distributed under the Boost Software License:
*
* Freeware for both open source and commercial applications
* Copyright 2010-2014 Angus Johnson
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
using System;
using System.Collections.Generic;
using java.util.logging;

namespace com.itextpdf.kernel.pdf.canvas.parser.clipper
{
	public abstract class ClipperBase : Clipper
	{
		protected internal class LocalMinima
		{
			internal long y;

			internal Edge leftBound;

			internal Edge rightBound;

			internal ClipperBase.LocalMinima next;

			internal LocalMinima(ClipperBase _enclosing)
			{
				this._enclosing = _enclosing;
			}

			private readonly ClipperBase _enclosing;
		}

		protected internal class Scanbeam
		{
			internal long y;

			internal ClipperBase.Scanbeam next;

			internal Scanbeam(ClipperBase _enclosing)
			{
				this._enclosing = _enclosing;
			}

			private readonly ClipperBase _enclosing;
		}

		private static void InitEdge(Edge e, Edge eNext, Edge ePrev, Point.LongPoint pt)
		{
			e.next = eNext;
			e.prev = ePrev;
			e.SetCurrent(new Point.LongPoint(pt));
			e.outIdx = Edge.UNASSIGNED;
		}

		private static void InitEdge2(Edge e, Clipper.PolyType polyType)
		{
			if (e.GetCurrent().GetY() >= e.next.GetCurrent().GetY())
			{
				e.SetBot(new Point.LongPoint(e.GetCurrent()));
				e.SetTop(new Point.LongPoint(e.next.GetCurrent()));
			}
			else
			{
				e.SetTop(new Point.LongPoint(e.GetCurrent()));
				e.SetBot(new Point.LongPoint(e.next.GetCurrent()));
			}
			e.UpdateDeltaX();
			e.polyTyp = polyType;
		}

		private static bool RangeTest(Point.LongPoint Pt, bool useFullRange)
		{
			if (useFullRange)
			{
				if (Pt.GetX() > HI_RANGE || Pt.GetY() > HI_RANGE || -Pt.GetX() > HI_RANGE || -Pt.
					GetY() > HI_RANGE)
				{
					throw new InvalidOperationException("Coordinate outside allowed range");
				}
			}
			else
			{
				if (Pt.GetX() > LOW_RANGE || Pt.GetY() > LOW_RANGE || -Pt.GetX() > LOW_RANGE || -
					Pt.GetY() > LOW_RANGE)
				{
					return RangeTest(Pt, true);
				}
			}
			return useFullRange;
		}

		private static Edge RemoveEdge(Edge e)
		{
			//removes e from double_linked_list (but without removing from memory)
			e.prev.next = e.next;
			e.next.prev = e.prev;
			Edge result = e.next;
			e.prev = null;
			//flag as removed (see ClipperBase.Clear)
			return result;
		}

		private const long LOW_RANGE = 0x3FFFFFFF;

		private const long HI_RANGE = 0x3FFFFFFFFFFFFFFFL;

		protected internal ClipperBase.LocalMinima minimaList;

		protected internal ClipperBase.LocalMinima currentLM;

		private readonly IList<IList<Edge>> edges;

		protected internal bool useFullRange;

		protected internal bool hasOpenPaths;

		protected internal readonly bool preserveCollinear;

		private static readonly Logger LOGGER = Logger.GetLogger(typeof(Clipper).GetName(
			));

		protected internal ClipperBase(bool preserveCollinear)
		{
			//constructor (nb: no external instantiation)
			this.preserveCollinear = preserveCollinear;
			minimaList = null;
			currentLM = null;
			hasOpenPaths = false;
			edges = new List<IList<Edge>>();
		}

		public override bool AddPath(Path pg, Clipper.PolyType polyType, bool Closed)
		{
			if (!Closed && polyType == Clipper.PolyType.CLIP)
			{
				throw new InvalidOperationException("AddPath: Open paths must be subject.");
			}
			int highI = pg.Count - 1;
			if (Closed)
			{
				while (highI > 0 && pg[highI].Equals(pg[0]))
				{
					--highI;
				}
			}
			while (highI > 0 && pg[highI].Equals(pg[highI - 1]))
			{
				--highI;
			}
			if (Closed && highI < 2 || !Closed && highI < 1)
			{
				return false;
			}
			//create a new edge array ...
			IList<Edge> edges = new List<Edge>(highI + 1);
			for (int i = 0; i <= highI; i++)
			{
				edges.Add(new Edge());
			}
			bool IsFlat = true;
			//1. Basic (first) edge initialization ...
			edges[1].SetCurrent(new Point.LongPoint(pg[1]));
			useFullRange = RangeTest(pg[0], useFullRange);
			useFullRange = RangeTest(pg[highI], useFullRange);
			InitEdge(edges[0], edges[1], edges[highI], pg[0]);
			InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);
			for (int i_1 = highI - 1; i_1 >= 1; --i_1)
			{
				useFullRange = RangeTest(pg[i_1], useFullRange);
				InitEdge(edges[i_1], edges[i_1 + 1], edges[i_1 - 1], pg[i_1]);
			}
			Edge eStart = edges[0];
			//2. Remove duplicate vertices, and (when closed) collinear edges ...
			Edge e = eStart;
			Edge eLoopStop = eStart;
			for (; ; )
			{
				//nb: allows matching start and end points when not Closed ...
				if (e.GetCurrent().Equals(e.next.GetCurrent()) && (Closed || !e.next.Equals(eStart
					)))
				{
					if (e == e.next)
					{
						break;
					}
					if (e == eStart)
					{
						eStart = e.next;
					}
					e = RemoveEdge(e);
					eLoopStop = e;
					continue;
				}
				if (e.prev == e.next)
				{
					break;
				}
				else
				{
					//only two vertices
					if (Closed && Point.SlopesEqual(e.prev.GetCurrent(), e.GetCurrent(), e.next.GetCurrent
						(), useFullRange) && (!IsPreserveCollinear() || !Point.IsPt2BetweenPt1AndPt3(e.prev
						.GetCurrent(), e.GetCurrent(), e.next.GetCurrent())))
					{
						//Collinear edges are allowed for open paths but in closed paths
						//the default is to merge adjacent collinear edges into a single edge.
						//However, if the PreserveCollinear property is enabled, only overlapping
						//collinear edges (ie spikes) will be removed from closed paths.
						if (e == eStart)
						{
							eStart = e.next;
						}
						e = RemoveEdge(e);
						e = e.prev;
						eLoopStop = e;
						continue;
					}
				}
				e = e.next;
				if (e == eLoopStop || !Closed && e.next == eStart)
				{
					break;
				}
			}
			if (!Closed && e == e.next || Closed && e.prev == e.next)
			{
				return false;
			}
			if (!Closed)
			{
				hasOpenPaths = true;
				eStart.prev.outIdx = Edge.SKIP;
			}
			//3. Do second stage of edge initialization ...
			e = eStart;
			do
			{
				InitEdge2(e, polyType);
				e = e.next;
				if (IsFlat && e.GetCurrent().GetY() != eStart.GetCurrent().GetY())
				{
					IsFlat = false;
				}
			}
			while (e != eStart);
			//4. Finally, add edge bounds to LocalMinima list ...
			//Totally flat paths must be handled differently when adding them
			//to LocalMinima list to avoid endless loops etc ...
			if (IsFlat)
			{
				if (Closed)
				{
					return false;
				}
				e.prev.outIdx = Edge.SKIP;
				ClipperBase.LocalMinima locMin = new ClipperBase.LocalMinima(this);
				locMin.next = null;
				locMin.y = e.GetBot().GetY();
				locMin.leftBound = null;
				locMin.rightBound = e;
				locMin.rightBound.side = Edge.Side.RIGHT;
				locMin.rightBound.windDelta = 0;
				for (; ; )
				{
					if (e.GetBot().GetX() != e.prev.GetTop().GetX())
					{
						e.ReverseHorizontal();
					}
					if (e.next.outIdx == Edge.SKIP)
					{
						break;
					}
					e.nextInLML = e.next;
					e = e.next;
				}
				InsertLocalMinima(locMin);
				this.edges.Add(edges);
				return true;
			}
			this.edges.Add(edges);
			bool leftBoundIsForward;
			Edge EMin = null;
			//workaround to avoid an endless loop in the while loop below when
			//open paths have matching start and end points ...
			if (e.prev.GetBot().Equals(e.prev.GetTop()))
			{
				e = e.next;
			}
			for (; ; )
			{
				e = e.FindNextLocMin();
				if (e == EMin)
				{
					break;
				}
				else
				{
					if (EMin == null)
					{
						EMin = e;
					}
				}
				//E and E.Prev now share a local minima (left aligned if horizontal).
				//Compare their slopes to find which starts which bound ...
				ClipperBase.LocalMinima locMin = new ClipperBase.LocalMinima(this);
				locMin.next = null;
				locMin.y = e.GetBot().GetY();
				if (e.deltaX < e.prev.deltaX)
				{
					locMin.leftBound = e.prev;
					locMin.rightBound = e;
					leftBoundIsForward = false;
				}
				else
				{
					//Q.nextInLML = Q.prev
					locMin.leftBound = e;
					locMin.rightBound = e.prev;
					leftBoundIsForward = true;
				}
				//Q.nextInLML = Q.next
				locMin.leftBound.side = Edge.Side.LEFT;
				locMin.rightBound.side = Edge.Side.RIGHT;
				if (!Closed)
				{
					locMin.leftBound.windDelta = 0;
				}
				else
				{
					if (locMin.leftBound.next == locMin.rightBound)
					{
						locMin.leftBound.windDelta = -1;
					}
					else
					{
						locMin.leftBound.windDelta = 1;
					}
				}
				locMin.rightBound.windDelta = -locMin.leftBound.windDelta;
				e = ProcessBound(locMin.leftBound, leftBoundIsForward);
				if (e.outIdx == Edge.SKIP)
				{
					e = ProcessBound(e, leftBoundIsForward);
				}
				Edge E2 = ProcessBound(locMin.rightBound, !leftBoundIsForward);
				if (E2.outIdx == Edge.SKIP)
				{
					E2 = ProcessBound(E2, !leftBoundIsForward);
				}
				if (locMin.leftBound.outIdx == Edge.SKIP)
				{
					locMin.leftBound = null;
				}
				else
				{
					if (locMin.rightBound.outIdx == Edge.SKIP)
					{
						locMin.rightBound = null;
					}
				}
				InsertLocalMinima(locMin);
				if (!leftBoundIsForward)
				{
					e = E2;
				}
			}
			return true;
		}

		public override bool AddPaths(Paths ppg, Clipper.PolyType polyType, bool closed)
		{
			bool result = false;
			for (int i = 0; i < ppg.Count; ++i)
			{
				if (AddPath(ppg[i], polyType, closed))
				{
					result = true;
				}
			}
			return result;
		}

		public override void Clear()
		{
			DisposeLocalMinimaList();
			edges.Clear();
			useFullRange = false;
			hasOpenPaths = false;
		}

		private void DisposeLocalMinimaList()
		{
			while (minimaList != null)
			{
				ClipperBase.LocalMinima tmpLm = minimaList.next;
				minimaList = null;
				minimaList = tmpLm;
			}
			currentLM = null;
		}

		private void InsertLocalMinima(ClipperBase.LocalMinima newLm)
		{
			if (minimaList == null)
			{
				minimaList = newLm;
			}
			else
			{
				if (newLm.y >= minimaList.y)
				{
					newLm.next = minimaList;
					minimaList = newLm;
				}
				else
				{
					ClipperBase.LocalMinima tmpLm = minimaList;
					while (tmpLm.next != null && newLm.y < tmpLm.next.y)
					{
						tmpLm = tmpLm.next;
					}
					newLm.next = tmpLm.next;
					tmpLm.next = newLm;
				}
			}
		}

		public virtual bool IsPreserveCollinear()
		{
			return preserveCollinear;
		}

		protected internal virtual void PopLocalMinima()
		{
			LOGGER.Entering(typeof(ClipperBase).GetName(), "popLocalMinima");
			if (currentLM == null)
			{
				return;
			}
			currentLM = currentLM.next;
		}

		private Edge ProcessBound(Edge e, bool LeftBoundIsForward)
		{
			Edge EStart;
			Edge result = e;
			Edge Horz;
			if (result.outIdx == Edge.SKIP)
			{
				//check if there are edges beyond the skip edge in the bound and if so
				//create another LocMin and calling ProcessBound once more ...
				e = result;
				if (LeftBoundIsForward)
				{
					while (e.GetTop().GetY() == e.next.GetBot().GetY())
					{
						e = e.next;
					}
					while (e != result && e.deltaX == Edge.HORIZONTAL)
					{
						e = e.prev;
					}
				}
				else
				{
					while (e.GetTop().GetY() == e.prev.GetBot().GetY())
					{
						e = e.prev;
					}
					while (e != result && e.deltaX == Edge.HORIZONTAL)
					{
						e = e.next;
					}
				}
				if (e == result)
				{
					if (LeftBoundIsForward)
					{
						result = e.next;
					}
					else
					{
						result = e.prev;
					}
				}
				else
				{
					//there are more edges in the bound beyond result starting with E
					if (LeftBoundIsForward)
					{
						e = result.next;
					}
					else
					{
						e = result.prev;
					}
					ClipperBase.LocalMinima locMin = new ClipperBase.LocalMinima(this);
					locMin.next = null;
					locMin.y = e.GetBot().GetY();
					locMin.leftBound = null;
					locMin.rightBound = e;
					e.windDelta = 0;
					result = ProcessBound(e, LeftBoundIsForward);
					InsertLocalMinima(locMin);
				}
				return result;
			}
			if (e.deltaX == Edge.HORIZONTAL)
			{
				//We need to be careful with open paths because this may not be a
				//true local minima (ie E may be following a skip edge).
				//Also, consecutive horz. edges may start heading left before going right.
				if (LeftBoundIsForward)
				{
					EStart = e.prev;
				}
				else
				{
					EStart = e.next;
				}
				if (EStart.deltaX == Edge.HORIZONTAL)
				{
					//ie an adjoining horizontal skip edge
					if (EStart.GetBot().GetX() != e.GetBot().GetX() && EStart.GetTop().GetX() != e.GetBot
						().GetX())
					{
						e.ReverseHorizontal();
					}
				}
				else
				{
					if (EStart.GetBot().GetX() != e.GetBot().GetX())
					{
						e.ReverseHorizontal();
					}
				}
			}
			EStart = e;
			if (LeftBoundIsForward)
			{
				while (result.GetTop().GetY() == result.next.GetBot().GetY() && result.next.outIdx
					 != Edge.SKIP)
				{
					result = result.next;
				}
				if (result.deltaX == Edge.HORIZONTAL && result.next.outIdx != Edge.SKIP)
				{
					//nb: at the top of a bound, horizontals are added to the bound
					//only when the preceding edge attaches to the horizontal's left vertex
					//unless a Skip edge is encountered when that becomes the top divide
					Horz = result;
					while (Horz.prev.deltaX == Edge.HORIZONTAL)
					{
						Horz = Horz.prev;
					}
					if (Horz.prev.GetTop().GetX() > result.next.GetTop().GetX())
					{
						result = Horz.prev;
					}
				}
				while (e != result)
				{
					e.nextInLML = e.next;
					if (e.deltaX == Edge.HORIZONTAL && e != EStart && e.GetBot().GetX() != e.prev.GetTop
						().GetX())
					{
						e.ReverseHorizontal();
					}
					e = e.next;
				}
				if (e.deltaX == Edge.HORIZONTAL && e != EStart && e.GetBot().GetX() != e.prev.GetTop
					().GetX())
				{
					e.ReverseHorizontal();
				}
				result = result.next;
			}
			else
			{
				//move to the edge just beyond current bound
				while (result.GetTop().GetY() == result.prev.GetBot().GetY() && result.prev.outIdx
					 != Edge.SKIP)
				{
					result = result.prev;
				}
				if (result.deltaX == Edge.HORIZONTAL && result.prev.outIdx != Edge.SKIP)
				{
					Horz = result;
					while (Horz.next.deltaX == Edge.HORIZONTAL)
					{
						Horz = Horz.next;
					}
					if (Horz.next.GetTop().GetX() == result.prev.GetTop().GetX() || Horz.next.GetTop(
						).GetX() > result.prev.GetTop().GetX())
					{
						result = Horz.next;
					}
				}
				while (e != result)
				{
					e.nextInLML = e.prev;
					if (e.deltaX == Edge.HORIZONTAL && e != EStart && e.GetBot().GetX() != e.next.GetTop
						().GetX())
					{
						e.ReverseHorizontal();
					}
					e = e.prev;
				}
				if (e.deltaX == Edge.HORIZONTAL && e != EStart && e.GetBot().GetX() != e.next.GetTop
					().GetX())
				{
					e.ReverseHorizontal();
				}
				result = result.prev;
			}
			//move to the edge just beyond current bound
			return result;
		}

		protected internal static Path.OutRec ParseFirstLeft(Path.OutRec FirstLeft)
		{
			while (FirstLeft != null && FirstLeft.GetPoints() == null)
			{
				FirstLeft = FirstLeft.firstLeft;
			}
			return FirstLeft;
		}

		protected internal virtual void Reset()
		{
			currentLM = minimaList;
			if (currentLM == null)
			{
				return;
			}
			//ie nothing to process
			//reset all edges ...
			ClipperBase.LocalMinima lm = minimaList;
			while (lm != null)
			{
				Edge e = lm.leftBound;
				if (e != null)
				{
					e.SetCurrent(new Point.LongPoint(e.GetBot()));
					e.side = Edge.Side.LEFT;
					e.outIdx = Edge.UNASSIGNED;
				}
				e = lm.rightBound;
				if (e != null)
				{
					e.SetCurrent(new Point.LongPoint(e.GetBot()));
					e.side = Edge.Side.RIGHT;
					e.outIdx = Edge.UNASSIGNED;
				}
				lm = lm.next;
			}
		}

		public abstract bool Execute(Clipper.ClipType arg1, Paths arg2);

		public abstract bool Execute(Clipper.ClipType arg1, Paths arg2, Clipper.PolyFillType
			 arg3, Clipper.PolyFillType arg4);

		public abstract bool Execute(Clipper.ClipType arg1, PolyTree arg2);

		public abstract bool Execute(Clipper.ClipType arg1, PolyTree arg2, Clipper.PolyFillType
			 arg3, Clipper.PolyFillType arg4);
	}
}
