/*
* $Id: 6e78648b3f0fac89b356218036abde60434b1791 $
*
* This file is part of the iText (R) project.
* Copyright (c) 2014-2015 iText Group NV
* Authors: Bruno Lowagie, Paulo Soares, et al.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License version 3
* as published by the Free Software Foundation with the addition of the
* following permission added to Section 15 as permitted in Section 7(a):
* FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
* ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
* OF THIRD PARTY RIGHTS
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE.
* See the GNU Affero General Public License for more details.
* You should have received a copy of the GNU Affero General Public License
* along with this program; if not, see http://www.gnu.org/licenses or write to
* the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA, 02110-1301 USA, or download the license from the following URL:
* http://itextpdf.com/terms-of-use/
*
* The interactive user interfaces in modified source and object code versions
* of this program must display Appropriate Legal Notices, as required under
* Section 5 of the GNU Affero General Public License.
*
* In accordance with Section 7(b) of the GNU Affero General Public License,
* a covered work must retain the producer line in every PDF that is created
* or manipulated using iText.
*
* You can be released from the requirements of the license by purchasing
* a commercial license. Buying such a license is mandatory as soon as you
* develop commercial activities involving the iText software without
* disclosing the source code of your own applications.
* These activities include: offering paid services to customers as an ASP,
* serving PDFs on the fly in a web application, shipping iText with a closed
* source product.
*
* For more information, please contact iText Software Corp. at this
* address: sales@itextpdf.com
*
*
* This class is based on the C# open source freeware library Clipper:
* http://www.angusj.com/delphi/clipper.php
* The original classes were distributed under the Boost Software License:
*
* Freeware for both open source and commercial applications
* Copyright 2010-2014 Angus Johnson
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
using System;
using System.Collections.Generic;
using java.util.logging;

namespace com.itextpdf.kernel.pdf.canvas.parser.clipper
{
	public class DefaultClipper : ClipperBase
	{
		private class IntersectNode
		{
			internal Edge edge1;

			internal Edge Edge2;

			private Point.LongPoint pt;

			public virtual Point.LongPoint GetPt()
			{
				return this.pt;
			}

			public virtual void SetPt(Point.LongPoint pt)
			{
				this.pt = pt;
			}

			internal IntersectNode(DefaultClipper _enclosing)
			{
				this._enclosing = _enclosing;
			}

			private readonly DefaultClipper _enclosing;
		}

		private static void GetHorzDirection(Edge HorzEdge, IClipper.Direction[] Dir, long
			[] Left, long[] Right)
		{
			if (HorzEdge.GetBot().GetX() < HorzEdge.GetTop().GetX())
			{
				Left[0] = HorzEdge.GetBot().GetX();
				Right[0] = HorzEdge.GetTop().GetX();
				Dir[0] = IClipper.Direction.LEFT_TO_RIGHT;
			}
			else
			{
				Left[0] = HorzEdge.GetTop().GetX();
				Right[0] = HorzEdge.GetBot().GetX();
				Dir[0] = IClipper.Direction.RIGHT_TO_LEFT;
			}
		}

		private static bool GetOverlap(long a1, long a2, long b1, long b2, long[] Left, long
			[] Right)
		{
			if (a1 < a2)
			{
				if (b1 < b2)
				{
					Left[0] = Math.Max(a1, b1);
					Right[0] = Math.Min(a2, b2);
				}
				else
				{
					Left[0] = Math.Max(a1, b2);
					Right[0] = Math.Min(a2, b1);
				}
			}
			else
			{
				if (b1 < b2)
				{
					Left[0] = Math.Max(a2, b1);
					Right[0] = Math.Min(a1, b2);
				}
				else
				{
					Left[0] = Math.Max(a2, b2);
					Right[0] = Math.Min(a1, b1);
				}
			}
			return Left[0] < Right[0];
		}

		private static bool IsParam1RightOfParam2(Path.OutRec outRec1, Path.OutRec outRec2
			)
		{
			do
			{
				outRec1 = outRec1.firstLeft;
				if (outRec1 == outRec2)
				{
					return true;
				}
			}
			while (outRec1 != null);
			return false;
		}

		//See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
		//http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
		private static int IsPointInPolygon(Point.LongPoint pt, Path.OutPt op)
		{
			//returns 0 if false, +1 if true, -1 if pt ON polygon boundary
			int result = 0;
			Path.OutPt startOp = op;
			long ptx = pt.GetX();
			long pty = pt.GetY();
			long poly0x = op.GetPt().GetX();
			long poly0y = op.GetPt().GetY();
			do
			{
				op = op.next;
				long poly1x = op.GetPt().GetX();
				long poly1y = op.GetPt().GetY();
				if (poly1y == pty)
				{
					if (poly1x == ptx || poly0y == pty && poly1x > ptx == poly0x < ptx)
					{
						return -1;
					}
				}
				if (poly0y < pty != poly1y < pty)
				{
					if (poly0x >= ptx)
					{
						if (poly1x > ptx)
						{
							result = 1 - result;
						}
						else
						{
							double d = (double)(poly0x - ptx) * (poly1y - pty) - (double)(poly1x - ptx) * (poly0y
								 - pty);
							if (d == 0)
							{
								return -1;
							}
							if (d > 0 == poly1y > poly0y)
							{
								result = 1 - result;
							}
						}
					}
					else
					{
						if (poly1x > ptx)
						{
							double d = (double)(poly0x - ptx) * (poly1y - pty) - (double)(poly1x - ptx) * (poly0y
								 - pty);
							if (d == 0)
							{
								return -1;
							}
							if (d > 0 == poly1y > poly0y)
							{
								result = 1 - result;
							}
						}
					}
				}
				poly0x = poly1x;
				poly0y = poly1y;
			}
			while (startOp != op);
			return result;
		}

		//------------------------------------------------------------------------------
		private static bool JoinHorz(Path.OutPt op1, Path.OutPt op1b, Path.OutPt op2, Path.OutPt
			 op2b, Point.LongPoint Pt, bool DiscardLeft)
		{
			IClipper.Direction Dir1 = op1.GetPt().GetX() > op1b.GetPt().GetX() ? IClipper.Direction
				.RIGHT_TO_LEFT : IClipper.Direction.LEFT_TO_RIGHT;
			IClipper.Direction Dir2 = op2.GetPt().GetX() > op2b.GetPt().GetX() ? IClipper.Direction
				.RIGHT_TO_LEFT : IClipper.Direction.LEFT_TO_RIGHT;
			if (Dir1 == Dir2)
			{
				return false;
			}
			//When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we
			//want Op1b to be on the Right. (And likewise with Op2 and Op2b.)
			//So, to facilitate this while inserting Op1b and Op2b ...
			//when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,
			//otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)
			if (Dir1 == IClipper.Direction.LEFT_TO_RIGHT)
			{
				while (op1.next.GetPt().GetX() <= Pt.GetX() && op1.next.GetPt().GetX() >= op1.GetPt
					().GetX() && op1.next.GetPt().GetY() == Pt.GetY())
				{
					op1 = op1.next;
				}
				if (DiscardLeft && op1.GetPt().GetX() != Pt.GetX())
				{
					op1 = op1.next;
				}
				op1b = op1.Duplicate(!DiscardLeft);
				if (!op1b.GetPt().Equals(Pt))
				{
					op1 = op1b;
					op1.SetPt(Pt);
					op1b = op1.Duplicate(!DiscardLeft);
				}
			}
			else
			{
				while (op1.next.GetPt().GetX() >= Pt.GetX() && op1.next.GetPt().GetX() <= op1.GetPt
					().GetX() && op1.next.GetPt().GetY() == Pt.GetY())
				{
					op1 = op1.next;
				}
				if (!DiscardLeft && op1.GetPt().GetX() != Pt.GetX())
				{
					op1 = op1.next;
				}
				op1b = op1.Duplicate(DiscardLeft);
				if (!op1b.GetPt().Equals(Pt))
				{
					op1 = op1b;
					op1.SetPt(Pt);
					op1b = op1.Duplicate(DiscardLeft);
				}
			}
			if (Dir2 == IClipper.Direction.LEFT_TO_RIGHT)
			{
				while (op2.next.GetPt().GetX() <= Pt.GetX() && op2.next.GetPt().GetX() >= op2.GetPt
					().GetX() && op2.next.GetPt().GetY() == Pt.GetY())
				{
					op2 = op2.next;
				}
				if (DiscardLeft && op2.GetPt().GetX() != Pt.GetX())
				{
					op2 = op2.next;
				}
				op2b = op2.Duplicate(!DiscardLeft);
				if (!op2b.GetPt().Equals(Pt))
				{
					op2 = op2b;
					op2.SetPt(Pt);
					op2b = op2.Duplicate(!DiscardLeft);
				}
			}
			else
			{
				while (op2.next.GetPt().GetX() >= Pt.GetX() && op2.next.GetPt().GetX() <= op2.GetPt
					().GetX() && op2.next.GetPt().GetY() == Pt.GetY())
				{
					op2 = op2.next;
				}
				if (!DiscardLeft && op2.GetPt().GetX() != Pt.GetX())
				{
					op2 = op2.next;
				}
				op2b = op2.Duplicate(DiscardLeft);
				if (!op2b.GetPt().Equals(Pt))
				{
					op2 = op2b;
					op2.SetPt(Pt);
					op2b = op2.Duplicate(DiscardLeft);
				}
			}
			if (Dir1 == IClipper.Direction.LEFT_TO_RIGHT == DiscardLeft)
			{
				op1.prev = op2;
				op2.next = op1;
				op1b.next = op2b;
				op2b.prev = op1b;
			}
			else
			{
				op1.next = op2;
				op2.prev = op1;
				op1b.prev = op2b;
				op2b.next = op1b;
			}
			return true;
		}

		private bool JoinPoints(Path.Join j, Path.OutRec outRec1, Path.OutRec outRec2)
		{
			Path.OutPt op1 = j.outPt1;
			Path.OutPt op1b;
			Path.OutPt op2 = j.outPt2;
			Path.OutPt op2b;
			//There are 3 kinds of joins for output polygons ...
			//1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere
			//along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).
			//2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same
			//location at the Bottom of the overlapping segment (& Join.OffPt is above).
			//3. StrictlySimple joins where edges touch but are not collinear and where
			//Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.
			bool isHorizontal = j.outPt1.GetPt().GetY() == j.GetOffPt().GetY();
			if (isHorizontal && j.GetOffPt().Equals(j.outPt1.GetPt()) && j.GetOffPt().Equals(
				j.outPt2.GetPt()))
			{
				//Strictly Simple join ...
				if (outRec1 != outRec2)
				{
					return false;
				}
				op1b = j.outPt1.next;
				while (op1b != op1 && op1b.GetPt().Equals(j.GetOffPt()))
				{
					op1b = op1b.next;
				}
				bool reverse1 = op1b.GetPt().GetY() > j.GetOffPt().GetY();
				op2b = j.outPt2.next;
				while (op2b != op2 && op2b.GetPt().Equals(j.GetOffPt()))
				{
					op2b = op2b.next;
				}
				bool reverse2 = op2b.GetPt().GetY() > j.GetOffPt().GetY();
				if (reverse1 == reverse2)
				{
					return false;
				}
				if (reverse1)
				{
					op1b = op1.Duplicate(false);
					op2b = op2.Duplicate(true);
					op1.prev = op2;
					op2.next = op1;
					op1b.next = op2b;
					op2b.prev = op1b;
					j.outPt1 = op1;
					j.outPt2 = op1b;
					return true;
				}
				else
				{
					op1b = op1.Duplicate(true);
					op2b = op2.Duplicate(false);
					op1.next = op2;
					op2.prev = op1;
					op1b.prev = op2b;
					op2b.next = op1b;
					j.outPt1 = op1;
					j.outPt2 = op1b;
					return true;
				}
			}
			else
			{
				if (isHorizontal)
				{
					//treat horizontal joins differently to non-horizontal joins since with
					//them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt
					//may be anywhere along the horizontal edge.
					op1b = op1;
					while (op1.prev.GetPt().GetY() == op1.GetPt().GetY() && op1.prev != op1b && op1.prev
						 != op2)
					{
						op1 = op1.prev;
					}
					while (op1b.next.GetPt().GetY() == op1b.GetPt().GetY() && op1b.next != op1 && op1b
						.next != op2)
					{
						op1b = op1b.next;
					}
					if (op1b.next == op1 || op1b.next == op2)
					{
						return false;
					}
					//a flat 'polygon'
					op2b = op2;
					while (op2.prev.GetPt().GetY() == op2.GetPt().GetY() && op2.prev != op2b && op2.prev
						 != op1b)
					{
						op2 = op2.prev;
					}
					while (op2b.next.GetPt().GetY() == op2b.GetPt().GetY() && op2b.next != op2 && op2b
						.next != op1)
					{
						op2b = op2b.next;
					}
					if (op2b.next == op2 || op2b.next == op1)
					{
						return false;
					}
					//a flat 'polygon'
					long[] LeftV = new long[1];
					long[] RightV = new long[1];
					//Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges
					if (!GetOverlap(op1.GetPt().GetX(), op1b.GetPt().GetX(), op2.GetPt().GetX(), op2b
						.GetPt().GetX(), LeftV, RightV))
					{
						return false;
					}
					long Left = LeftV[0];
					long Right = RightV[0];
					//DiscardLeftSide: when overlapping edges are joined, a spike will created
					//which needs to be cleaned up. However, we don't want Op1 or Op2 caught up
					//on the discard Side as either may still be needed for other joins ...
					Point.LongPoint Pt;
					bool DiscardLeftSide;
					if (op1.GetPt().GetX() >= Left && op1.GetPt().GetX() <= Right)
					{
						Pt = new Point.LongPoint(op1.GetPt());
						DiscardLeftSide = op1.GetPt().GetX() > op1b.GetPt().GetX();
					}
					else
					{
						if (op2.GetPt().GetX() >= Left && op2.GetPt().GetX() <= Right)
						{
							Pt = new Point.LongPoint(op2.GetPt());
							DiscardLeftSide = op2.GetPt().GetX() > op2b.GetPt().GetX();
						}
						else
						{
							if (op1b.GetPt().GetX() >= Left && op1b.GetPt().GetX() <= Right)
							{
								Pt = new Point.LongPoint(op1b.GetPt());
								DiscardLeftSide = op1b.GetPt().GetX() > op1.GetPt().GetX();
							}
							else
							{
								Pt = new Point.LongPoint(op2b.GetPt());
								DiscardLeftSide = op2b.GetPt().GetX() > op2.GetPt().GetX();
							}
						}
					}
					j.outPt1 = op1;
					j.outPt2 = op2;
					return JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);
				}
				else
				{
					//nb: For non-horizontal joins ...
					//    1. Jr.OutPt1.getPt().getY() == Jr.OutPt2.getPt().getY()
					//    2. Jr.OutPt1.Pt > Jr.OffPt.getY()
					//make sure the polygons are correctly oriented ...
					op1b = op1.next;
					while (op1b.GetPt().Equals(op1.GetPt()) && op1b != op1)
					{
						op1b = op1b.next;
					}
					bool Reverse1 = op1b.GetPt().GetY() > op1.GetPt().GetY() || !Point.SlopesEqual(op1
						.GetPt(), op1b.GetPt(), j.GetOffPt(), useFullRange);
					if (Reverse1)
					{
						op1b = op1.prev;
						while (op1b.GetPt().Equals(op1.GetPt()) && op1b != op1)
						{
							op1b = op1b.prev;
						}
						if (op1b.GetPt().GetY() > op1.GetPt().GetY() || !Point.SlopesEqual(op1.GetPt(), op1b
							.GetPt(), j.GetOffPt(), useFullRange))
						{
							return false;
						}
					}
					op2b = op2.next;
					while (op2b.GetPt().Equals(op2.GetPt()) && op2b != op2)
					{
						op2b = op2b.next;
					}
					bool Reverse2 = op2b.GetPt().GetY() > op2.GetPt().GetY() || !Point.SlopesEqual(op2
						.GetPt(), op2b.GetPt(), j.GetOffPt(), useFullRange);
					if (Reverse2)
					{
						op2b = op2.prev;
						while (op2b.GetPt().Equals(op2.GetPt()) && op2b != op2)
						{
							op2b = op2b.prev;
						}
						if (op2b.GetPt().GetY() > op2.GetPt().GetY() || !Point.SlopesEqual(op2.GetPt(), op2b
							.GetPt(), j.GetOffPt(), useFullRange))
						{
							return false;
						}
					}
					if (op1b == op1 || op2b == op2 || op1b == op2b || outRec1 == outRec2 && Reverse1 
						== Reverse2)
					{
						return false;
					}
					if (Reverse1)
					{
						op1b = op1.Duplicate(false);
						op2b = op2.Duplicate(true);
						op1.prev = op2;
						op2.next = op1;
						op1b.next = op2b;
						op2b.prev = op1b;
						j.outPt1 = op1;
						j.outPt2 = op1b;
						return true;
					}
					else
					{
						op1b = op1.Duplicate(true);
						op2b = op2.Duplicate(false);
						op1.next = op2;
						op2.prev = op1;
						op1b.prev = op2b;
						op2b.next = op1b;
						j.outPt1 = op1;
						j.outPt2 = op1b;
						return true;
					}
				}
			}
		}

		private static Paths Minkowski(Path pattern, Path path, bool IsSum, bool IsClosed
			)
		{
			int delta = IsClosed ? 1 : 0;
			int polyCnt = pattern.Count;
			int pathCnt = path.Count;
			Paths result = new Paths(pathCnt);
			if (IsSum)
			{
				for (int i = 0; i < pathCnt; i++)
				{
					Path p = new Path(polyCnt);
					foreach (Point.LongPoint ip in pattern)
					{
						p.Add(new Point.LongPoint(path[i].GetX() + ip.GetX(), path[i].GetY() + ip.GetY(), 
							0));
					}
					result.Add(p);
				}
			}
			else
			{
				for (int i = 0; i < pathCnt; i++)
				{
					Path p = new Path(polyCnt);
					foreach (Point.LongPoint ip in pattern)
					{
						p.Add(new Point.LongPoint(path[i].GetX() - ip.GetX(), path[i].GetY() - ip.GetY(), 
							0));
					}
					result.Add(p);
				}
			}
			Paths quads = new Paths((pathCnt + delta) * (polyCnt + 1));
			for (int i_1 = 0; i_1 < pathCnt - 1 + delta; i_1++)
			{
				for (int j = 0; j < polyCnt; j++)
				{
					Path quad = new Path(4);
					quad.Add(result[i_1 % pathCnt][j % polyCnt]);
					quad.Add(result[(i_1 + 1) % pathCnt][j % polyCnt]);
					quad.Add(result[(i_1 + 1) % pathCnt][(j + 1) % polyCnt]);
					quad.Add(result[i_1 % pathCnt][(j + 1) % polyCnt]);
					if (!quad.Orientation())
					{
						Collections.Reverse(quad);
					}
					quads.Add(quad);
				}
			}
			return quads;
		}

		public static Paths MinkowskiDiff(Path poly1, Path poly2)
		{
			Paths paths = Minkowski(poly1, poly2, false, true);
			DefaultClipper c = new DefaultClipper();
			c.AddPaths(paths, IClipper.PolyType.SUBJECT, true);
			c.Execute(IClipper.ClipType.UNION, paths, IClipper.PolyFillType.NON_ZERO, IClipper.PolyFillType
				.NON_ZERO);
			return paths;
		}

		public static Paths MinkowskiSum(Path pattern, Path path, bool pathIsClosed)
		{
			Paths paths = Minkowski(pattern, path, true, pathIsClosed);
			DefaultClipper c = new DefaultClipper();
			c.AddPaths(paths, IClipper.PolyType.SUBJECT, true);
			c.Execute(IClipper.ClipType.UNION, paths, IClipper.PolyFillType.NON_ZERO, IClipper.PolyFillType
				.NON_ZERO);
			return paths;
		}

		public static Paths MinkowskiSum(Path pattern, Paths paths, bool pathIsClosed)
		{
			Paths solution = new Paths();
			DefaultClipper c = new DefaultClipper();
			for (int i = 0; i < paths.Count; ++i)
			{
				Paths tmp = Minkowski(pattern, paths[i], true, pathIsClosed);
				c.AddPaths(tmp, IClipper.PolyType.SUBJECT, true);
				if (pathIsClosed)
				{
					Path path = paths[i].TranslatePath(pattern[0]);
					c.AddPath(path, IClipper.PolyType.CLIP, true);
				}
			}
			c.Execute(IClipper.ClipType.UNION, solution, IClipper.PolyFillType.NON_ZERO, IClipper.PolyFillType
				.NON_ZERO);
			return solution;
		}

		private static bool Poly2ContainsPoly1(Path.OutPt outPt1, Path.OutPt outPt2)
		{
			Path.OutPt op = outPt1;
			do
			{
				//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon
				int res = IsPointInPolygon(op.GetPt(), outPt2);
				if (res >= 0)
				{
					return res > 0;
				}
				op = op.next;
			}
			while (op != outPt1);
			return true;
		}

		//------------------------------------------------------------------------------
		// SimplifyPolygon functions ...
		// Convert self-intersecting polygons into simple polygons
		//------------------------------------------------------------------------------
		public static Paths SimplifyPolygon(Path poly)
		{
			return SimplifyPolygon(poly, IClipper.PolyFillType.EVEN_ODD);
		}

		public static Paths SimplifyPolygon(Path poly, IClipper.PolyFillType fillType)
		{
			Paths result = new Paths();
			DefaultClipper c = new DefaultClipper(STRICTLY_SIMPLE);
			c.AddPath(poly, IClipper.PolyType.SUBJECT, true);
			c.Execute(IClipper.ClipType.UNION, result, fillType, fillType);
			return result;
		}

		public static Paths SimplifyPolygons(Paths polys)
		{
			return SimplifyPolygons(polys, IClipper.PolyFillType.EVEN_ODD);
		}

		public static Paths SimplifyPolygons(Paths polys, IClipper.PolyFillType fillType)
		{
			Paths result = new Paths();
			DefaultClipper c = new DefaultClipper(STRICTLY_SIMPLE);
			c.AddPaths(polys, IClipper.PolyType.SUBJECT, true);
			c.Execute(IClipper.ClipType.UNION, result, fillType, fillType);
			return result;
		}

		protected internal readonly IList<Path.OutRec> polyOuts;

		private IClipper.ClipType clipType;

		private ClipperBase.Scanbeam scanbeam;

		private Path.Maxima maxima;

		private Edge activeEdges;

		private Edge sortedEdges;

		private readonly IList<DefaultClipper.IntersectNode> intersectList;

		private readonly Comparator<DefaultClipper.IntersectNode> intersectNodeComparer;

		private IClipper.PolyFillType clipFillType;

		private IClipper.PolyFillType subjFillType;

		private readonly IList<Path.Join> joins;

		private readonly IList<Path.Join> ghostJoins;

		private bool usingPolyTree;

		public IClipper.IZFillCallback zFillFunction;

		private readonly bool reverseSolution;

		private readonly bool strictlySimple;

		private static readonly Logger LOGGER = Logger.GetLogger(typeof(DefaultClipper).GetName
			());

		public DefaultClipper()
			: this(0)
		{
		}

		public DefaultClipper(int InitOptions)
			: base((PRESERVE_COLINEAR & InitOptions) != 0)
		{
			//------------------------------------------------------------------------------
			//------------------------------------------------------------------------------
			//------------------------------------------------------------------------------
			//------------------------------------------------------------------------------
			//------------------------------------------------------------------------------
			//constructor
			scanbeam = null;
			maxima = null;
			activeEdges = null;
			sortedEdges = null;
			intersectList = new List<DefaultClipper.IntersectNode>();
			intersectNodeComparer = new _Comparator_643();
			usingPolyTree = false;
			polyOuts = new List<Path.OutRec>();
			joins = new List<Path.Join>();
			ghostJoins = new List<Path.Join>();
			reverseSolution = (REVERSE_SOLUTION & InitOptions) != 0;
			strictlySimple = (STRICTLY_SIMPLE & InitOptions) != 0;
			zFillFunction = null;
		}

		private sealed class _Comparator_643 : Comparator<DefaultClipper.IntersectNode>
		{
			public _Comparator_643()
			{
			}

			public int Compare(DefaultClipper.IntersectNode o1, DefaultClipper.IntersectNode 
				o2)
			{
				long i = o2.GetPt().GetY() - o1.GetPt().GetY();
				if (i > 0)
				{
					return 1;
				}
				else
				{
					if (i < 0)
					{
						return -1;
					}
					else
					{
						return 0;
					}
				}
			}
		}

		private void InsertScanbeam(long Y)
		{
			//single-linked list: sorted descending, ignoring dups.
			if (scanbeam == null)
			{
				scanbeam = new ClipperBase.Scanbeam(this);
				scanbeam.next = null;
				scanbeam.y = Y;
			}
			else
			{
				if (Y > scanbeam.y)
				{
					ClipperBase.Scanbeam newSb = new ClipperBase.Scanbeam(this);
					newSb.y = Y;
					newSb.next = scanbeam;
					scanbeam = newSb;
				}
				else
				{
					ClipperBase.Scanbeam sb2 = scanbeam;
					while (sb2.next != null && (Y <= sb2.next.y))
					{
						sb2 = sb2.next;
					}
					if (Y == sb2.y)
					{
						return;
					}
					//ie ignores duplicates
					ClipperBase.Scanbeam newSb = new ClipperBase.Scanbeam(this);
					newSb.y = Y;
					newSb.next = sb2.next;
					sb2.next = newSb;
				}
			}
		}

		//------------------------------------------------------------------------------
		private void InsertMaxima(long X)
		{
			//double-linked list: sorted ascending, ignoring dups.
			Path.Maxima newMax = new Path.Maxima();
			newMax.X = X;
			if (maxima == null)
			{
				maxima = newMax;
				maxima.Next = null;
				maxima.Prev = null;
			}
			else
			{
				if (X < maxima.X)
				{
					newMax.Next = maxima;
					newMax.Prev = null;
					maxima = newMax;
				}
				else
				{
					Path.Maxima m = maxima;
					while (m.Next != null && (X >= m.Next.X))
					{
						m = m.Next;
					}
					if (X == m.X)
					{
						return;
					}
					//ie ignores duplicates (& CG to clean up newMax)
					//insert newMax between m and m.Next ...
					newMax.Next = m.Next;
					newMax.Prev = m;
					if (m.Next != null)
					{
						m.Next.Prev = newMax;
					}
					m.Next = newMax;
				}
			}
		}

		//------------------------------------------------------------------------------
		private void AddEdgeToSEL(Edge edge)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "addEdgeToSEL");
			//SEL pointers in PEdge are reused to build a list of horizontal edges.
			//However, we don't need to worry about order with horizontal edge processing.
			if (sortedEdges == null)
			{
				sortedEdges = edge;
				edge.prevInSEL = null;
				edge.nextInSEL = null;
			}
			else
			{
				edge.nextInSEL = sortedEdges;
				edge.prevInSEL = null;
				sortedEdges.prevInSEL = edge;
				sortedEdges = edge;
			}
		}

		private void AddGhostJoin(Path.OutPt Op, Point.LongPoint OffPt)
		{
			Path.Join j = new Path.Join();
			j.outPt1 = Op;
			j.SetOffPt(OffPt);
			ghostJoins.Add(j);
		}

		//------------------------------------------------------------------------------
		private void AddJoin(Path.OutPt Op1, Path.OutPt Op2, Point.LongPoint OffPt)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "addJoin");
			Path.Join j = new Path.Join();
			j.outPt1 = Op1;
			j.outPt2 = Op2;
			j.SetOffPt(OffPt);
			joins.Add(j);
		}

		//------------------------------------------------------------------------------
		private void AddLocalMaxPoly(Edge e1, Edge e2, Point.LongPoint pt)
		{
			AddOutPt(e1, pt);
			if (e2.windDelta == 0)
			{
				AddOutPt(e2, pt);
			}
			if (e1.outIdx == e2.outIdx)
			{
				e1.outIdx = Edge.UNASSIGNED;
				e2.outIdx = Edge.UNASSIGNED;
			}
			else
			{
				if (e1.outIdx < e2.outIdx)
				{
					AppendPolygon(e1, e2);
				}
				else
				{
					AppendPolygon(e2, e1);
				}
			}
		}

		//------------------------------------------------------------------------------
		private Path.OutPt AddLocalMinPoly(Edge e1, Edge e2, Point.LongPoint pt)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "addLocalMinPoly");
			Path.OutPt result;
			Edge e;
			Edge prevE;
			if (e2.IsHorizontal() || e1.deltaX > e2.deltaX)
			{
				result = AddOutPt(e1, pt);
				e2.outIdx = e1.outIdx;
				e1.side = Edge.Side.LEFT;
				e2.side = Edge.Side.RIGHT;
				e = e1;
				if (e.prevInAEL == e2)
				{
					prevE = e2.prevInAEL;
				}
				else
				{
					prevE = e.prevInAEL;
				}
			}
			else
			{
				result = AddOutPt(e2, pt);
				e1.outIdx = e2.outIdx;
				e1.side = Edge.Side.RIGHT;
				e2.side = Edge.Side.LEFT;
				e = e2;
				if (e.prevInAEL == e1)
				{
					prevE = e1.prevInAEL;
				}
				else
				{
					prevE = e.prevInAEL;
				}
			}
			if (prevE != null && prevE.outIdx >= 0 && Edge.TopX(prevE, pt.GetY()) == Edge.TopX
				(e, pt.GetY()) && Edge.SlopesEqual(e, prevE, useFullRange) && e.windDelta != 0 &&
				 prevE.windDelta != 0)
			{
				Path.OutPt outPt = AddOutPt(prevE, pt);
				AddJoin(result, outPt, e.GetTop());
			}
			return result;
		}

		private Path.OutPt AddOutPt(Edge e, Point.LongPoint pt)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "addOutPt");
			if (e.outIdx < 0)
			{
				Path.OutRec outRec = CreateOutRec();
				outRec.isOpen = (e.windDelta == 0);
				Path.OutPt newOp = new Path.OutPt();
				outRec.pts = newOp;
				newOp.idx = outRec.Idx;
				newOp.pt = pt;
				newOp.next = newOp;
				newOp.prev = newOp;
				if (!outRec.isOpen)
				{
					SetHoleState(e, outRec);
				}
				e.outIdx = outRec.Idx;
				//nb: do this after SetZ !
				return newOp;
			}
			else
			{
				Path.OutRec outRec = polyOuts[e.outIdx];
				//OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'
				Path.OutPt op = outRec.GetPoints();
				bool ToFront = (e.side == Edge.Side.LEFT);
				LOGGER.Finest("op=" + op.GetPointCount());
				LOGGER.Finest(ToFront + " " + pt + " " + op.GetPt());
				if (ToFront && pt.Equals(op.GetPt()))
				{
					return op;
				}
				else
				{
					if (!ToFront && pt.Equals(op.prev.GetPt()))
					{
						return op.prev;
					}
				}
				Path.OutPt newOp = new Path.OutPt();
				newOp.idx = outRec.Idx;
				newOp.SetPt(new Point.LongPoint(pt));
				newOp.next = op;
				newOp.prev = op.prev;
				newOp.prev.next = newOp;
				op.prev = newOp;
				if (ToFront)
				{
					outRec.SetPoints(newOp);
				}
				return newOp;
			}
		}

		private Path.OutPt GetLastOutPt(Edge e)
		{
			Path.OutRec outRec = polyOuts[e.outIdx];
			if (e.side == Edge.Side.LEFT)
			{
				return outRec.pts;
			}
			else
			{
				return outRec.pts.prev;
			}
		}

		//------------------------------------------------------------------------------
		private void AppendPolygon(Edge e1, Edge e2)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "appendPolygon");
			//get the start and ends of both output polygons ...
			Path.OutRec outRec1 = polyOuts[e1.outIdx];
			Path.OutRec outRec2 = polyOuts[e2.outIdx];
			LOGGER.Finest("" + e1.outIdx);
			LOGGER.Finest("" + e2.outIdx);
			Path.OutRec holeStateRec;
			if (IsParam1RightOfParam2(outRec1, outRec2))
			{
				holeStateRec = outRec2;
			}
			else
			{
				if (IsParam1RightOfParam2(outRec2, outRec1))
				{
					holeStateRec = outRec1;
				}
				else
				{
					holeStateRec = Path.OutPt.GetLowerMostRec(outRec1, outRec2);
				}
			}
			Path.OutPt p1_lft = outRec1.GetPoints();
			Path.OutPt p1_rt = p1_lft.prev;
			Path.OutPt p2_lft = outRec2.GetPoints();
			Path.OutPt p2_rt = p2_lft.prev;
			LOGGER.Finest("p1_lft.getPointCount() = " + p1_lft.GetPointCount());
			LOGGER.Finest("p1_rt.getPointCount() = " + p1_rt.GetPointCount());
			LOGGER.Finest("p2_lft.getPointCount() = " + p2_lft.GetPointCount());
			LOGGER.Finest("p2_rt.getPointCount() = " + p2_rt.GetPointCount());
			Edge.Side side;
			//join e2 poly onto e1 poly and delete pointers to e2 ...
			if (e1.side == Edge.Side.LEFT)
			{
				if (e2.side == Edge.Side.LEFT)
				{
					//z y x a b c
					p2_lft.ReversePolyPtLinks();
					p2_lft.next = p1_lft;
					p1_lft.prev = p2_lft;
					p1_rt.next = p2_rt;
					p2_rt.prev = p1_rt;
					outRec1.SetPoints(p2_rt);
				}
				else
				{
					//x y z a b c
					p2_rt.next = p1_lft;
					p1_lft.prev = p2_rt;
					p2_lft.prev = p1_rt;
					p1_rt.next = p2_lft;
					outRec1.SetPoints(p2_lft);
				}
				side = Edge.Side.LEFT;
			}
			else
			{
				if (e2.side == Edge.Side.RIGHT)
				{
					//a b c z y x
					p2_lft.ReversePolyPtLinks();
					p1_rt.next = p2_rt;
					p2_rt.prev = p1_rt;
					p2_lft.next = p1_lft;
					p1_lft.prev = p2_lft;
				}
				else
				{
					//a b c x y z
					p1_rt.next = p2_lft;
					p2_lft.prev = p1_rt;
					p1_lft.prev = p2_rt;
					p2_rt.next = p1_lft;
				}
				side = Edge.Side.RIGHT;
			}
			outRec1.bottomPt = null;
			if (holeStateRec.Equals(outRec2))
			{
				if (outRec2.firstLeft != outRec1)
				{
					outRec1.firstLeft = outRec2.firstLeft;
				}
				outRec1.isHole = outRec2.isHole;
			}
			outRec2.SetPoints(null);
			outRec2.bottomPt = null;
			outRec2.firstLeft = outRec1;
			int OKIdx = e1.outIdx;
			int ObsoleteIdx = e2.outIdx;
			e1.outIdx = Edge.UNASSIGNED;
			//nb: safe because we only get here via AddLocalMaxPoly
			e2.outIdx = Edge.UNASSIGNED;
			Edge e = activeEdges;
			while (e != null)
			{
				if (e.outIdx == ObsoleteIdx)
				{
					e.outIdx = OKIdx;
					e.side = side;
					break;
				}
				e = e.nextInAEL;
			}
			outRec2.Idx = outRec1.Idx;
		}

		//------------------------------------------------------------------------------
		private void BuildIntersectList(long topY)
		{
			if (activeEdges == null)
			{
				return;
			}
			//prepare for sorting ...
			Edge e = activeEdges;
			sortedEdges = e;
			while (e != null)
			{
				e.prevInSEL = e.prevInAEL;
				e.nextInSEL = e.nextInAEL;
				e.GetCurrent().SetX(Edge.TopX(e, topY));
				e = e.nextInAEL;
			}
			//bubblesort ...
			bool isModified = true;
			while (isModified && sortedEdges != null)
			{
				isModified = false;
				e = sortedEdges;
				while (e.nextInSEL != null)
				{
					Edge eNext = e.nextInSEL;
					Point.LongPoint[] pt = new Point.LongPoint[1];
					if (e.GetCurrent().GetX() > eNext.GetCurrent().GetX())
					{
						IntersectPoint(e, eNext, pt);
						DefaultClipper.IntersectNode newNode = new DefaultClipper.IntersectNode(this);
						newNode.edge1 = e;
						newNode.Edge2 = eNext;
						newNode.SetPt(pt[0]);
						intersectList.Add(newNode);
						SwapPositionsInSEL(e, eNext);
						isModified = true;
					}
					else
					{
						e = eNext;
					}
				}
				if (e.prevInSEL != null)
				{
					e.prevInSEL.nextInSEL = null;
				}
				else
				{
					break;
				}
			}
			sortedEdges = null;
		}

		//------------------------------------------------------------------------------
		private void BuildResult(Paths polyg)
		{
			polyg.Clear();
			for (int i = 0; i < polyOuts.Count; i++)
			{
				Path.OutRec outRec = polyOuts[i];
				if (outRec.GetPoints() == null)
				{
					continue;
				}
				Path.OutPt p = outRec.GetPoints().prev;
				int cnt = p.GetPointCount();
				LOGGER.Finest("cnt = " + cnt);
				if (cnt < 2)
				{
					continue;
				}
				Path pg = new Path(cnt);
				for (int j = 0; j < cnt; j++)
				{
					pg.Add(p.GetPt());
					p = p.prev;
				}
				polyg.Add(pg);
			}
		}

		private void BuildResult2(PolyTree polytree)
		{
			polytree.Clear();
			//add each output polygon/contour to polytree ...
			for (int i = 0; i < polyOuts.Count; i++)
			{
				Path.OutRec outRec = polyOuts[i];
				int cnt = outRec.GetPoints() != null ? outRec.GetPoints().GetPointCount() : 0;
				if (outRec.isOpen && cnt < 2 || !outRec.isOpen && cnt < 3)
				{
					continue;
				}
				outRec.FixHoleLinkage();
				PolyNode pn = new PolyNode();
				polytree.GetAllPolys().Add(pn);
				outRec.polyNode = pn;
				Path.OutPt op = outRec.GetPoints().prev;
				for (int j = 0; j < cnt; j++)
				{
					pn.GetPolygon().Add(op.GetPt());
					op = op.prev;
				}
			}
			//fixup PolyNode links etc ...
			for (int i_1 = 0; i_1 < polyOuts.Count; i_1++)
			{
				Path.OutRec outRec = polyOuts[i_1];
				if (outRec.polyNode == null)
				{
					continue;
				}
				else
				{
					if (outRec.isOpen)
					{
						outRec.polyNode.SetOpen(true);
						polytree.AddChild(outRec.polyNode);
					}
					else
					{
						if (outRec.firstLeft != null && outRec.firstLeft.polyNode != null)
						{
							outRec.firstLeft.polyNode.AddChild(outRec.polyNode);
						}
						else
						{
							polytree.AddChild(outRec.polyNode);
						}
					}
				}
			}
		}

		private void CopyAELToSEL()
		{
			Edge e = activeEdges;
			sortedEdges = e;
			while (e != null)
			{
				e.prevInSEL = e.prevInAEL;
				e.nextInSEL = e.nextInAEL;
				e = e.nextInAEL;
			}
		}

		private Path.OutRec CreateOutRec()
		{
			Path.OutRec result = new Path.OutRec();
			result.Idx = Edge.UNASSIGNED;
			result.isHole = false;
			result.isOpen = false;
			result.firstLeft = null;
			result.SetPoints(null);
			result.bottomPt = null;
			result.polyNode = null;
			polyOuts.Add(result);
			result.Idx = polyOuts.Count - 1;
			return result;
		}

		private void DeleteFromAEL(Edge e)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "deleteFromAEL");
			Edge AelPrev = e.prevInAEL;
			Edge AelNext = e.nextInAEL;
			if (AelPrev == null && AelNext == null && e != activeEdges)
			{
				return;
			}
			//already deleted
			if (AelPrev != null)
			{
				AelPrev.nextInAEL = AelNext;
			}
			else
			{
				activeEdges = AelNext;
			}
			if (AelNext != null)
			{
				AelNext.prevInAEL = AelPrev;
			}
			e.nextInAEL = null;
			e.prevInAEL = null;
			LOGGER.Exiting(typeof(DefaultClipper).GetName(), "deleteFromAEL");
		}

		private void DeleteFromSEL(Edge e)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "deleteFromSEL");
			Edge SelPrev = e.prevInSEL;
			Edge SelNext = e.nextInSEL;
			if (SelPrev == null && SelNext == null && !e.Equals(sortedEdges))
			{
				return;
			}
			//already deleted
			if (SelPrev != null)
			{
				SelPrev.nextInSEL = SelNext;
			}
			else
			{
				sortedEdges = SelNext;
			}
			if (SelNext != null)
			{
				SelNext.prevInSEL = SelPrev;
			}
			e.nextInSEL = null;
			e.prevInSEL = null;
		}

		private bool DoHorzSegmentsOverlap(long seg1a, long seg1b, long seg2a, long seg2b
			)
		{
			if (seg1a > seg1b)
			{
				long tmp = seg1a;
				seg1a = seg1b;
				seg1b = tmp;
			}
			if (seg2a > seg2b)
			{
				long tmp = seg2a;
				seg2a = seg2b;
				seg2b = tmp;
			}
			return (seg1a < seg2b) && (seg2a < seg1b);
		}

		private void DoMaxima(Edge e)
		{
			Edge eMaxPair = e.GetMaximaPair();
			if (eMaxPair == null)
			{
				if (e.outIdx >= 0)
				{
					AddOutPt(e, e.GetTop());
				}
				DeleteFromAEL(e);
				return;
			}
			Edge eNext = e.nextInAEL;
			while (eNext != null && eNext != eMaxPair)
			{
				Point.LongPoint tmp = new Point.LongPoint(e.GetTop());
				IntersectEdges(e, eNext, tmp);
				e.SetTop(tmp);
				SwapPositionsInAEL(e, eNext);
				eNext = e.nextInAEL;
			}
			if (e.outIdx == Edge.UNASSIGNED && eMaxPair.outIdx == Edge.UNASSIGNED)
			{
				DeleteFromAEL(e);
				DeleteFromAEL(eMaxPair);
			}
			else
			{
				if (e.outIdx >= 0 && eMaxPair.outIdx >= 0)
				{
					if (e.outIdx >= 0)
					{
						AddLocalMaxPoly(e, eMaxPair, e.GetTop());
					}
					DeleteFromAEL(e);
					DeleteFromAEL(eMaxPair);
				}
				else
				{
					if (e.windDelta == 0)
					{
						if (e.outIdx >= 0)
						{
							AddOutPt(e, e.GetTop());
							e.outIdx = Edge.UNASSIGNED;
						}
						DeleteFromAEL(e);
						if (eMaxPair.outIdx >= 0)
						{
							AddOutPt(eMaxPair, e.GetTop());
							eMaxPair.outIdx = Edge.UNASSIGNED;
						}
						DeleteFromAEL(eMaxPair);
					}
					else
					{
						throw new InvalidOperationException("DoMaxima error");
					}
				}
			}
		}

		//------------------------------------------------------------------------------
		private void DoSimplePolygons()
		{
			int i = 0;
			while (i < polyOuts.Count)
			{
				Path.OutRec outrec = polyOuts[i++];
				Path.OutPt op = outrec.GetPoints();
				if (op == null || outrec.isOpen)
				{
					continue;
				}
				do
				{
					//for each Pt in Polygon until duplicate found do ...
					Path.OutPt op2 = op.next;
					while (op2 != outrec.GetPoints())
					{
						if (op.GetPt().Equals(op2.GetPt()) && !op2.next.Equals(op) && !op2.prev.Equals(op
							))
						{
							//split the polygon into two ...
							Path.OutPt op3 = op.prev;
							Path.OutPt op4 = op2.prev;
							op.prev = op4;
							op4.next = op;
							op2.prev = op3;
							op3.next = op2;
							outrec.SetPoints(op);
							Path.OutRec outrec2 = CreateOutRec();
							outrec2.SetPoints(op2);
							UpdateOutPtIdxs(outrec2);
							if (Poly2ContainsPoly1(outrec2.GetPoints(), outrec.GetPoints()))
							{
								//OutRec2 is contained by OutRec1 ...
								outrec2.isHole = !outrec.isHole;
								outrec2.firstLeft = outrec;
								if (usingPolyTree)
								{
									FixupFirstLefts2(outrec2, outrec);
								}
							}
							else
							{
								if (Poly2ContainsPoly1(outrec.GetPoints(), outrec2.GetPoints()))
								{
									//OutRec1 is contained by OutRec2 ...
									outrec2.isHole = outrec.isHole;
									outrec.isHole = !outrec2.isHole;
									outrec2.firstLeft = outrec.firstLeft;
									outrec.firstLeft = outrec2;
									if (usingPolyTree)
									{
										FixupFirstLefts2(outrec, outrec2);
									}
								}
								else
								{
									//the 2 polygons are separate ...
									outrec2.isHole = outrec.isHole;
									outrec2.firstLeft = outrec.firstLeft;
									if (usingPolyTree)
									{
										FixupFirstLefts1(outrec, outrec2);
									}
								}
							}
							op2 = op;
						}
						//ie get ready for the next iteration
						op2 = op2.next;
					}
					op = op.next;
				}
				while (op != outrec.GetPoints());
			}
		}

		//------------------------------------------------------------------------------
		private bool EdgesAdjacent(DefaultClipper.IntersectNode inode)
		{
			return inode.edge1.nextInSEL == inode.Edge2 || inode.edge1.prevInSEL == inode.Edge2;
		}

		//------------------------------------------------------------------------------
		public virtual bool Execute(IClipper.ClipType clipType, Paths solution, IClipper.PolyFillType
			 FillType)
		{
			return Execute(clipType, solution, FillType, FillType);
		}

		public override bool Execute(IClipper.ClipType clipType, PolyTree polytree)
		{
			return Execute(clipType, polytree, IClipper.PolyFillType.EVEN_ODD);
		}

		public virtual bool Execute(IClipper.ClipType clipType, PolyTree polytree, IClipper.PolyFillType
			 FillType)
		{
			return Execute(clipType, polytree, FillType, FillType);
		}

		public override bool Execute(IClipper.ClipType clipType, Paths solution)
		{
			return Execute(clipType, solution, IClipper.PolyFillType.EVEN_ODD);
		}

		public override bool Execute(IClipper.ClipType clipType, Paths solution, IClipper.PolyFillType
			 subjFillType, IClipper.PolyFillType clipFillType)
		{
			lock (this)
			{
				if (hasOpenPaths)
				{
					throw new InvalidOperationException("Error: PolyTree struct is needed for open path clipping."
						);
				}
				solution.Clear();
				this.subjFillType = subjFillType;
				this.clipFillType = clipFillType;
				this.clipType = clipType;
				usingPolyTree = false;
				bool succeeded;
				try
				{
					succeeded = ExecuteInternal();
					//build the return polygons ...
					if (succeeded)
					{
						BuildResult(solution);
					}
					return succeeded;
				}
				finally
				{
					polyOuts.Clear();
				}
			}
		}

		public override bool Execute(IClipper.ClipType clipType, PolyTree polytree, IClipper.PolyFillType
			 subjFillType, IClipper.PolyFillType clipFillType)
		{
			lock (this)
			{
				this.subjFillType = subjFillType;
				this.clipFillType = clipFillType;
				this.clipType = clipType;
				usingPolyTree = true;
				bool succeeded;
				try
				{
					succeeded = ExecuteInternal();
					//build the return polygons ...
					if (succeeded)
					{
						BuildResult2(polytree);
					}
				}
				finally
				{
					polyOuts.Clear();
				}
				return succeeded;
			}
		}

		//------------------------------------------------------------------------------
		private bool ExecuteInternal()
		{
			try
			{
				Reset();
				if (currentLM == null)
				{
					return false;
				}
				long botY = PopScanbeam();
				do
				{
					InsertLocalMinimaIntoAEL(botY);
					ProcessHorizontals();
					ghostJoins.Clear();
					if (scanbeam == null)
					{
						break;
					}
					long topY = PopScanbeam();
					if (!ProcessIntersections(topY))
					{
						return false;
					}
					ProcessEdgesAtTopOfScanbeam(topY);
					botY = topY;
				}
				while (scanbeam != null || currentLM != null);
				//fix orientations ...
				for (int i = 0; i < polyOuts.Count; i++)
				{
					Path.OutRec outRec = polyOuts[i];
					if (outRec.pts == null || outRec.isOpen)
					{
						continue;
					}
					if ((outRec.isHole ^ reverseSolution) == (outRec.Area() > 0))
					{
						outRec.GetPoints().ReversePolyPtLinks();
					}
				}
				JoinCommonEdges();
				for (int i_1 = 0; i_1 < polyOuts.Count; i_1++)
				{
					Path.OutRec outRec = polyOuts[i_1];
					if (outRec.GetPoints() == null)
					{
						continue;
					}
					else
					{
						if (outRec.isOpen)
						{
							FixupOutPolyline(outRec);
						}
						else
						{
							FixupOutPolygon(outRec);
						}
					}
				}
				if (strictlySimple)
				{
					DoSimplePolygons();
				}
				return true;
			}
			finally
			{
				//catch { return false; }
				joins.Clear();
				ghostJoins.Clear();
			}
		}

		//------------------------------------------------------------------------------
		private void FixupFirstLefts1(Path.OutRec OldOutRec, Path.OutRec NewOutRec)
		{
			for (int i = 0; i < polyOuts.Count; i++)
			{
				Path.OutRec outRec = polyOuts[i];
				if (outRec.GetPoints() == null || outRec.firstLeft == null)
				{
					continue;
				}
				Path.OutRec firstLeft = ParseFirstLeft(outRec.firstLeft);
				if (firstLeft.Equals(OldOutRec))
				{
					if (Poly2ContainsPoly1(outRec.GetPoints(), NewOutRec.GetPoints()))
					{
						outRec.firstLeft = NewOutRec;
					}
				}
			}
		}

		private void FixupFirstLefts2(Path.OutRec OldOutRec, Path.OutRec NewOutRec)
		{
			foreach (Path.OutRec outRec in polyOuts)
			{
				if (outRec.firstLeft == OldOutRec)
				{
					outRec.firstLeft = NewOutRec;
				}
			}
		}

		private bool FixupIntersectionOrder()
		{
			//pre-condition: intersections are sorted bottom-most first.
			//Now it's crucial that intersections are made only between adjacent edges,
			//so to ensure this the order of intersections may need adjusting ...
			intersectList.Sort(intersectNodeComparer);
			CopyAELToSEL();
			int cnt = intersectList.Count;
			for (int i = 0; i < cnt; i++)
			{
				if (!EdgesAdjacent(intersectList[i]))
				{
					int j = i + 1;
					while (j < cnt && !EdgesAdjacent(intersectList[j]))
					{
						j++;
					}
					if (j == cnt)
					{
						return false;
					}
					DefaultClipper.IntersectNode tmp = intersectList[i];
					intersectList[i] = intersectList[j];
					intersectList[j] = tmp;
				}
				SwapPositionsInSEL(intersectList[i].edge1, intersectList[i].Edge2);
			}
			return true;
		}

		//----------------------------------------------------------------------
		private void FixupOutPolyline(Path.OutRec outrec)
		{
			Path.OutPt pp = outrec.pts;
			Path.OutPt lastPP = pp.prev;
			while (pp != lastPP)
			{
				pp = pp.next;
				if (pp.pt.Equals(pp.prev.pt))
				{
					if (pp == lastPP)
					{
						lastPP = pp.prev;
					}
					Path.OutPt tmpPP = pp.prev;
					tmpPP.next = pp.next;
					pp.next.prev = tmpPP;
					pp = tmpPP;
				}
			}
			if (pp == pp.prev)
			{
				outrec.pts = null;
			}
		}

		private void FixupOutPolygon(Path.OutRec outRec)
		{
			//FixupOutPolygon() - removes duplicate points and simplifies consecutive
			//parallel edges by removing the middle vertex.
			Path.OutPt lastOK = null;
			outRec.bottomPt = null;
			Path.OutPt pp = outRec.GetPoints();
			bool preserveCol = preserveCollinear || strictlySimple;
			for (; ; )
			{
				if (pp.prev == pp || pp.prev == pp.next)
				{
					outRec.SetPoints(null);
					return;
				}
				//test for duplicate points and collinear edges ...
				if (pp.GetPt().Equals(pp.next.GetPt()) || pp.GetPt().Equals(pp.prev.GetPt()) || Point
					.SlopesEqual(pp.prev.GetPt(), pp.GetPt(), pp.next.GetPt(), useFullRange) && (!preserveCol
					 || !Point.IsPt2BetweenPt1AndPt3(pp.prev.GetPt(), pp.GetPt(), pp.next.GetPt())))
				{
					lastOK = null;
					pp.prev.next = pp.next;
					pp.next.prev = pp.prev;
					pp = pp.prev;
				}
				else
				{
					if (pp == lastOK)
					{
						break;
					}
					else
					{
						if (lastOK == null)
						{
							lastOK = pp;
						}
						pp = pp.next;
					}
				}
			}
			outRec.SetPoints(pp);
		}

		private Path.OutRec GetOutRec(int idx)
		{
			Path.OutRec outrec = polyOuts[idx];
			while (outrec != polyOuts[outrec.Idx])
			{
				outrec = polyOuts[outrec.Idx];
			}
			return outrec;
		}

		private void InsertEdgeIntoAEL(Edge edge, Edge startEdge)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "insertEdgeIntoAEL");
			if (activeEdges == null)
			{
				edge.prevInAEL = null;
				edge.nextInAEL = null;
				LOGGER.Finest("Edge " + edge.outIdx + " -> " + null);
				activeEdges = edge;
			}
			else
			{
				if (startEdge == null && Edge.DoesE2InsertBeforeE1(activeEdges, edge))
				{
					edge.prevInAEL = null;
					edge.nextInAEL = activeEdges;
					LOGGER.Finest("Edge " + edge.outIdx + " -> " + edge.nextInAEL.outIdx);
					activeEdges.prevInAEL = edge;
					activeEdges = edge;
				}
				else
				{
					LOGGER.Finest("activeEdges unchanged");
					if (startEdge == null)
					{
						startEdge = activeEdges;
					}
					while (startEdge.nextInAEL != null && !Edge.DoesE2InsertBeforeE1(startEdge.nextInAEL
						, edge))
					{
						startEdge = startEdge.nextInAEL;
					}
					edge.nextInAEL = startEdge.nextInAEL;
					if (startEdge.nextInAEL != null)
					{
						startEdge.nextInAEL.prevInAEL = edge;
					}
					edge.prevInAEL = startEdge;
					startEdge.nextInAEL = edge;
				}
			}
		}

		//------------------------------------------------------------------------------
		private void InsertLocalMinimaIntoAEL(long botY)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "insertLocalMinimaIntoAEL");
			while (currentLM != null && currentLM.y == botY)
			{
				Edge lb = currentLM.leftBound;
				Edge rb = currentLM.rightBound;
				PopLocalMinima();
				Path.OutPt Op1 = null;
				if (lb == null)
				{
					InsertEdgeIntoAEL(rb, null);
					UpdateWindingCount(rb);
					if (rb.IsContributing(clipFillType, subjFillType, clipType))
					{
						Op1 = AddOutPt(rb, rb.GetBot());
					}
				}
				else
				{
					if (rb == null)
					{
						InsertEdgeIntoAEL(lb, null);
						UpdateWindingCount(lb);
						if (lb.IsContributing(clipFillType, subjFillType, clipType))
						{
							Op1 = AddOutPt(lb, lb.GetBot());
						}
						InsertScanbeam(lb.GetTop().GetY());
					}
					else
					{
						InsertEdgeIntoAEL(lb, null);
						InsertEdgeIntoAEL(rb, lb);
						UpdateWindingCount(lb);
						rb.windCnt = lb.windCnt;
						rb.windCnt2 = lb.windCnt2;
						if (lb.IsContributing(clipFillType, subjFillType, clipType))
						{
							Op1 = AddLocalMinPoly(lb, rb, lb.GetBot());
						}
						InsertScanbeam(lb.GetTop().GetY());
					}
				}
				if (rb != null)
				{
					if (rb.IsHorizontal())
					{
						AddEdgeToSEL(rb);
					}
					else
					{
						InsertScanbeam(rb.GetTop().GetY());
					}
				}
				if (lb == null || rb == null)
				{
					continue;
				}
				//if output polygons share an Edge with a horizontal rb, they'll need joining later ...
				if (Op1 != null && rb.IsHorizontal() && ghostJoins.Count > 0 && rb.windDelta != 0)
				{
					for (int i = 0; i < ghostJoins.Count; i++)
					{
						//if the horizontal Rb and a 'ghost' horizontal overlap, then convert
						//the 'ghost' join to a real join ready for later ...
						Path.Join j = ghostJoins[i];
						if (DoHorzSegmentsOverlap(j.outPt1.GetPt().GetX(), j.GetOffPt().GetX(), rb.GetBot
							().GetX(), rb.GetTop().GetX()))
						{
							AddJoin(j.outPt1, Op1, j.GetOffPt());
						}
					}
				}
				if (lb.outIdx >= 0 && lb.prevInAEL != null && lb.prevInAEL.GetCurrent().GetX() ==
					 lb.GetBot().GetX() && lb.prevInAEL.outIdx >= 0 && Edge.SlopesEqual(lb.prevInAEL
					, lb, useFullRange) && lb.windDelta != 0 && lb.prevInAEL.windDelta != 0)
				{
					Path.OutPt Op2 = AddOutPt(lb.prevInAEL, lb.GetBot());
					AddJoin(Op1, Op2, lb.GetTop());
				}
				if (lb.nextInAEL != rb)
				{
					if (rb.outIdx >= 0 && rb.prevInAEL.outIdx >= 0 && Edge.SlopesEqual(rb.prevInAEL, 
						rb, useFullRange) && rb.windDelta != 0 && rb.prevInAEL.windDelta != 0)
					{
						Path.OutPt Op2 = AddOutPt(rb.prevInAEL, rb.GetBot());
						AddJoin(Op1, Op2, rb.GetTop());
					}
					Edge e = lb.nextInAEL;
					if (e != null)
					{
						while (e != rb)
						{
							//nb: For calculating winding counts etc, IntersectEdges() assumes
							//that param1 will be to the right of param2 ABOVE the intersection ...
							IntersectEdges(rb, e, lb.GetCurrent());
							//order important here
							e = e.nextInAEL;
						}
					}
				}
			}
		}

		//------------------------------------------------------------------------------
		//    private void insertScanbeam( long y ) {
		//        LOGGER.entering( DefaultClipper.class.getName(), "insertScanbeam" );
		//
		//        if (scanbeam == null) {
		//            scanbeam = new Scanbeam();
		//            scanbeam.next = null;
		//            scanbeam.y = y;
		//        }
		//        else if (y > scanbeam.y) {
		//            final Scanbeam newSb = new Scanbeam();
		//            newSb.y = y;
		//            newSb.next = scanbeam;
		//            scanbeam = newSb;
		//        }
		//        else {
		//            Scanbeam sb2 = scanbeam;
		//            while (sb2.next != null && y <= sb2.next.y) {
		//                sb2 = sb2.next;
		//            }
		//            if (y == sb2.y) {
		//                return; //ie ignores duplicates
		//            }
		//            final Scanbeam newSb = new Scanbeam();
		//            newSb.y = y;
		//            newSb.next = sb2.next;
		//            sb2.next = newSb;
		//        }
		//    }
		//------------------------------------------------------------------------------
		private void IntersectEdges(Edge e1, Edge e2, Point.LongPoint pt)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "insersectEdges");
			//e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before
			//e2 in AEL except when e1 is being inserted at the intersection point ...
			bool e1Contributing = e1.outIdx >= 0;
			bool e2Contributing = e2.outIdx >= 0;
			SetZ(pt, e1, e2);
			//if either edge is on an OPEN path ...
			if (e1.windDelta == 0 || e2.windDelta == 0)
			{
				//ignore subject-subject open path intersections UNLESS they
				//are both open paths, AND they are both 'contributing maximas' ...
				if (e1.windDelta == 0 && e2.windDelta == 0)
				{
					return;
				}
				else
				{
					if (e1.polyTyp == e2.polyTyp && e1.windDelta != e2.windDelta && clipType == IClipper.ClipType
						.UNION)
					{
						if (e1.windDelta == 0)
						{
							if (e2Contributing)
							{
								AddOutPt(e1, pt);
								if (e1Contributing)
								{
									e1.outIdx = Edge.UNASSIGNED;
								}
							}
						}
						else
						{
							if (e1Contributing)
							{
								AddOutPt(e2, pt);
								if (e2Contributing)
								{
									e2.outIdx = Edge.UNASSIGNED;
								}
							}
						}
					}
					else
					{
						if (e1.polyTyp != e2.polyTyp)
						{
							if (e1.windDelta == 0 && Math.Abs(e2.windCnt) == 1 && (clipType != IClipper.ClipType
								.UNION || e2.windCnt2 == 0))
							{
								AddOutPt(e1, pt);
								if (e1Contributing)
								{
									e1.outIdx = Edge.UNASSIGNED;
								}
							}
							else
							{
								if (e2.windDelta == 0 && Math.Abs(e1.windCnt) == 1 && (clipType != IClipper.ClipType
									.UNION || e1.windCnt2 == 0))
								{
									AddOutPt(e2, pt);
									if (e2Contributing)
									{
										e2.outIdx = Edge.UNASSIGNED;
									}
								}
							}
						}
					}
				}
				return;
			}
			//update winding counts...
			//assumes that e1 will be to the Right of e2 ABOVE the intersection
			if (e1.polyTyp == e2.polyTyp)
			{
				if (e1.IsEvenOddFillType(clipFillType, subjFillType))
				{
					int oldE1WindCnt = e1.windCnt;
					e1.windCnt = e2.windCnt;
					e2.windCnt = oldE1WindCnt;
				}
				else
				{
					if (e1.windCnt + e2.windDelta == 0)
					{
						e1.windCnt = -e1.windCnt;
					}
					else
					{
						e1.windCnt += e2.windDelta;
					}
					if (e2.windCnt - e1.windDelta == 0)
					{
						e2.windCnt = -e2.windCnt;
					}
					else
					{
						e2.windCnt -= e1.windDelta;
					}
				}
			}
			else
			{
				if (!e2.IsEvenOddFillType(clipFillType, subjFillType))
				{
					e1.windCnt2 += e2.windDelta;
				}
				else
				{
					e1.windCnt2 = e1.windCnt2 == 0 ? 1 : 0;
				}
				if (!e1.IsEvenOddFillType(clipFillType, subjFillType))
				{
					e2.windCnt2 -= e1.windDelta;
				}
				else
				{
					e2.windCnt2 = e2.windCnt2 == 0 ? 1 : 0;
				}
			}
			IClipper.PolyFillType e1FillType;
			IClipper.PolyFillType e2FillType;
			IClipper.PolyFillType e1FillType2;
			IClipper.PolyFillType e2FillType2;
			if (e1.polyTyp == IClipper.PolyType.SUBJECT)
			{
				e1FillType = subjFillType;
				e1FillType2 = clipFillType;
			}
			else
			{
				e1FillType = clipFillType;
				e1FillType2 = subjFillType;
			}
			if (e2.polyTyp == IClipper.PolyType.SUBJECT)
			{
				e2FillType = subjFillType;
				e2FillType2 = clipFillType;
			}
			else
			{
				e2FillType = clipFillType;
				e2FillType2 = subjFillType;
			}
			int e1Wc;
			int e2Wc;
			switch (e1FillType)
			{
				case IClipper.PolyFillType.POSITIVE:
				{
					e1Wc = e1.windCnt;
					break;
				}

				case IClipper.PolyFillType.NEGATIVE:
				{
					e1Wc = -e1.windCnt;
					break;
				}

				default:
				{
					e1Wc = Math.Abs(e1.windCnt);
					break;
				}
			}
			switch (e2FillType)
			{
				case IClipper.PolyFillType.POSITIVE:
				{
					e2Wc = e2.windCnt;
					break;
				}

				case IClipper.PolyFillType.NEGATIVE:
				{
					e2Wc = -e2.windCnt;
					break;
				}

				default:
				{
					e2Wc = Math.Abs(e2.windCnt);
					break;
				}
			}
			if (e1Contributing && e2Contributing)
			{
				if (e1Wc != 0 && e1Wc != 1 || e2Wc != 0 && e2Wc != 1 || e1.polyTyp != e2.polyTyp 
					&& clipType != IClipper.ClipType.XOR)
				{
					AddLocalMaxPoly(e1, e2, pt);
				}
				else
				{
					AddOutPt(e1, pt);
					AddOutPt(e2, pt);
					Edge.SwapSides(e1, e2);
					Edge.SwapPolyIndexes(e1, e2);
				}
			}
			else
			{
				if (e1Contributing)
				{
					if (e2Wc == 0 || e2Wc == 1)
					{
						AddOutPt(e1, pt);
						Edge.SwapSides(e1, e2);
						Edge.SwapPolyIndexes(e1, e2);
					}
				}
				else
				{
					if (e2Contributing)
					{
						if (e1Wc == 0 || e1Wc == 1)
						{
							AddOutPt(e2, pt);
							Edge.SwapSides(e1, e2);
							Edge.SwapPolyIndexes(e1, e2);
						}
					}
					else
					{
						if ((e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))
						{
							//neither edge is currently contributing ...
							int e1Wc2;
							int e2Wc2;
							switch (e1FillType2)
							{
								case IClipper.PolyFillType.POSITIVE:
								{
									e1Wc2 = e1.windCnt2;
									break;
								}

								case IClipper.PolyFillType.NEGATIVE:
								{
									e1Wc2 = -e1.windCnt2;
									break;
								}

								default:
								{
									e1Wc2 = Math.Abs(e1.windCnt2);
									break;
								}
							}
							switch (e2FillType2)
							{
								case IClipper.PolyFillType.POSITIVE:
								{
									e2Wc2 = e2.windCnt2;
									break;
								}

								case IClipper.PolyFillType.NEGATIVE:
								{
									e2Wc2 = -e2.windCnt2;
									break;
								}

								default:
								{
									e2Wc2 = Math.Abs(e2.windCnt2);
									break;
								}
							}
							if (e1.polyTyp != e2.polyTyp)
							{
								AddLocalMinPoly(e1, e2, pt);
							}
							else
							{
								if (e1Wc == 1 && e2Wc == 1)
								{
									switch (clipType)
									{
										case IClipper.ClipType.INTERSECTION:
										{
											if (e1Wc2 > 0 && e2Wc2 > 0)
											{
												AddLocalMinPoly(e1, e2, pt);
											}
											break;
										}

										case IClipper.ClipType.UNION:
										{
											if (e1Wc2 <= 0 && e2Wc2 <= 0)
											{
												AddLocalMinPoly(e1, e2, pt);
											}
											break;
										}

										case IClipper.ClipType.DIFFERENCE:
										{
											if (e1.polyTyp == IClipper.PolyType.CLIP && e1Wc2 > 0 && e2Wc2 > 0 || e1.polyTyp 
												== IClipper.PolyType.SUBJECT && e1Wc2 <= 0 && e2Wc2 <= 0)
											{
												AddLocalMinPoly(e1, e2, pt);
											}
											break;
										}

										case IClipper.ClipType.XOR:
										{
											AddLocalMinPoly(e1, e2, pt);
											break;
										}
									}
								}
								else
								{
									Edge.SwapSides(e1, e2);
								}
							}
						}
					}
				}
			}
		}

		private void IntersectPoint(Edge edge1, Edge edge2, Point.LongPoint[] ipV)
		{
			Point.LongPoint ip = ipV[0] = new Point.LongPoint();
			double b1;
			double b2;
			//nb: with very large coordinate values, it's possible for SlopesEqual() to
			//return false but for the edge.Dx value be equal due to double precision rounding.
			if (edge1.deltaX == edge2.deltaX)
			{
				ip.SetY(edge1.GetCurrent().GetY());
				ip.SetX(Edge.TopX(edge1, ip.GetY()));
				return;
			}
			if (edge1.GetDelta().GetX() == 0)
			{
				ip.SetX(edge1.GetBot().GetX());
				if (edge2.IsHorizontal())
				{
					ip.SetY(edge2.GetBot().GetY());
				}
				else
				{
					b2 = edge2.GetBot().GetY() - edge2.GetBot().GetX() / edge2.deltaX;
					ip.SetY(Math.Round(ip.GetX() / edge2.deltaX + b2));
				}
			}
			else
			{
				if (edge2.GetDelta().GetX() == 0)
				{
					ip.SetX(edge2.GetBot().GetX());
					if (edge1.IsHorizontal())
					{
						ip.SetY(edge1.GetBot().GetY());
					}
					else
					{
						b1 = edge1.GetBot().GetY() - edge1.GetBot().GetX() / edge1.deltaX;
						ip.SetY(Math.Round(ip.GetX() / edge1.deltaX + b1));
					}
				}
				else
				{
					b1 = edge1.GetBot().GetX() - edge1.GetBot().GetY() * edge1.deltaX;
					b2 = edge2.GetBot().GetX() - edge2.GetBot().GetY() * edge2.deltaX;
					double q = (b2 - b1) / (edge1.deltaX - edge2.deltaX);
					ip.SetY(Math.Round(q));
					if (Math.Abs(edge1.deltaX) < Math.Abs(edge2.deltaX))
					{
						ip.SetX(Math.Round(edge1.deltaX * q + b1));
					}
					else
					{
						ip.SetX(Math.Round(edge2.deltaX * q + b2));
					}
				}
			}
			if (ip.GetY() < edge1.GetTop().GetY() || ip.GetY() < edge2.GetTop().GetY())
			{
				if (edge1.GetTop().GetY() > edge2.GetTop().GetY())
				{
					ip.SetY(edge1.GetTop().GetY());
				}
				else
				{
					ip.SetY(edge2.GetTop().GetY());
				}
				if (Math.Abs(edge1.deltaX) < Math.Abs(edge2.deltaX))
				{
					ip.SetX(Edge.TopX(edge1, ip.GetY()));
				}
				else
				{
					ip.SetX(Edge.TopX(edge2, ip.GetY()));
				}
			}
			//finally, don't allow 'ip' to be BELOW curr.getY() (ie bottom of scanbeam) ...
			if (ip.GetY() > edge1.GetCurrent().GetY())
			{
				ip.SetY(edge1.GetCurrent().GetY());
				//better to use the more vertical edge to derive X ...
				if (Math.Abs(edge1.deltaX) > Math.Abs(edge2.deltaX))
				{
					ip.SetX(Edge.TopX(edge2, ip.GetY()));
				}
				else
				{
					ip.SetX(Edge.TopX(edge1, ip.GetY()));
				}
			}
		}

		private void JoinCommonEdges()
		{
			for (int i = 0; i < joins.Count; i++)
			{
				Path.Join join = joins[i];
				Path.OutRec outRec1 = GetOutRec(join.outPt1.idx);
				Path.OutRec outRec2 = GetOutRec(join.outPt2.idx);
				if (outRec1.GetPoints() == null || outRec2.GetPoints() == null)
				{
					continue;
				}
				if (outRec1.isOpen || outRec2.isOpen)
				{
					continue;
				}
				//get the polygon fragment with the correct hole state (FirstLeft)
				//before calling JoinPoints() ...
				Path.OutRec holeStateRec;
				if (outRec1 == outRec2)
				{
					holeStateRec = outRec1;
				}
				else
				{
					if (IsParam1RightOfParam2(outRec1, outRec2))
					{
						holeStateRec = outRec2;
					}
					else
					{
						if (IsParam1RightOfParam2(outRec2, outRec1))
						{
							holeStateRec = outRec1;
						}
						else
						{
							holeStateRec = Path.OutPt.GetLowerMostRec(outRec1, outRec2);
						}
					}
				}
				if (!JoinPoints(join, outRec1, outRec2))
				{
					continue;
				}
				if (outRec1 == outRec2)
				{
					//instead of joining two polygons, we've just created a new one by
					//splitting one polygon into two.
					outRec1.SetPoints(join.outPt1);
					outRec1.bottomPt = null;
					outRec2 = CreateOutRec();
					outRec2.SetPoints(join.outPt2);
					//update all OutRec2.Pts Idx's ...
					UpdateOutPtIdxs(outRec2);
					//We now need to check every OutRec.FirstLeft pointer. If it points
					//to OutRec1 it may need to point to OutRec2 instead ...
					if (usingPolyTree)
					{
						for (int j = 0; j < polyOuts.Count - 1; j++)
						{
							Path.OutRec oRec = polyOuts[j];
							if (oRec.GetPoints() == null || ParseFirstLeft(oRec.firstLeft) != outRec1 || oRec
								.isHole == outRec1.isHole)
							{
								continue;
							}
							if (Poly2ContainsPoly1(oRec.GetPoints(), join.outPt2))
							{
								oRec.firstLeft = outRec2;
							}
						}
					}
					if (Poly2ContainsPoly1(outRec2.GetPoints(), outRec1.GetPoints()))
					{
						//outRec2 is contained by outRec1 ...
						outRec2.isHole = !outRec1.isHole;
						outRec2.firstLeft = outRec1;
						//fixup FirstLeft pointers that may need reassigning to OutRec1
						if (usingPolyTree)
						{
							FixupFirstLefts2(outRec2, outRec1);
						}
						if ((outRec2.isHole ^ reverseSolution) == outRec2.Area() > 0)
						{
							outRec2.GetPoints().ReversePolyPtLinks();
						}
					}
					else
					{
						if (Poly2ContainsPoly1(outRec1.GetPoints(), outRec2.GetPoints()))
						{
							//outRec1 is contained by outRec2 ...
							outRec2.isHole = outRec1.isHole;
							outRec1.isHole = !outRec2.isHole;
							outRec2.firstLeft = outRec1.firstLeft;
							outRec1.firstLeft = outRec2;
							//fixup FirstLeft pointers that may need reassigning to OutRec1
							if (usingPolyTree)
							{
								FixupFirstLefts2(outRec1, outRec2);
							}
							if ((outRec1.isHole ^ reverseSolution) == outRec1.Area() > 0)
							{
								outRec1.GetPoints().ReversePolyPtLinks();
							}
						}
						else
						{
							//the 2 polygons are completely separate ...
							outRec2.isHole = outRec1.isHole;
							outRec2.firstLeft = outRec1.firstLeft;
							//fixup FirstLeft pointers that may need reassigning to OutRec2
							if (usingPolyTree)
							{
								FixupFirstLefts1(outRec1, outRec2);
							}
						}
					}
				}
				else
				{
					//joined 2 polygons together ...
					outRec2.SetPoints(null);
					outRec2.bottomPt = null;
					outRec2.Idx = outRec1.Idx;
					outRec1.isHole = holeStateRec.isHole;
					if (holeStateRec == outRec2)
					{
						outRec1.firstLeft = outRec2.firstLeft;
					}
					outRec2.firstLeft = outRec1;
					//fixup FirstLeft pointers that may need reassigning to OutRec1
					if (usingPolyTree)
					{
						FixupFirstLefts2(outRec2, outRec1);
					}
				}
			}
		}

		private long PopScanbeam()
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "popBeam");
			long y = scanbeam.y;
			scanbeam = scanbeam.next;
			return y;
		}

		private void ProcessEdgesAtTopOfScanbeam(long topY)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "processEdgesAtTopOfScanbeam");
			Edge e = activeEdges;
			while (e != null)
			{
				//1. process maxima, treating them as if they're 'bent' horizontal edges,
				//   but exclude maxima with horizontal edges. nb: e can't be a horizontal.
				bool IsMaximaEdge = e.IsMaxima(topY);
				if (IsMaximaEdge)
				{
					Edge eMaxPair = e.GetMaximaPair();
					IsMaximaEdge = eMaxPair == null || !eMaxPair.IsHorizontal();
				}
				if (IsMaximaEdge)
				{
					if (strictlySimple)
					{
						InsertMaxima(e.GetTop().GetX());
					}
					Edge ePrev = e.prevInAEL;
					DoMaxima(e);
					if (ePrev == null)
					{
						e = activeEdges;
					}
					else
					{
						e = ePrev.nextInAEL;
					}
				}
				else
				{
					//2. promote horizontal edges, otherwise update Curr.getX() and Curr.getY() ...
					if (e.IsIntermediate(topY) && e.nextInLML.IsHorizontal())
					{
						Edge[] t = new Edge[] { e };
						UpdateEdgeIntoAEL(t);
						e = t[0];
						if (e.outIdx >= 0)
						{
							AddOutPt(e, e.GetBot());
						}
						AddEdgeToSEL(e);
					}
					else
					{
						e.GetCurrent().SetX(Edge.TopX(e, topY));
						e.GetCurrent().SetY(topY);
					}
					//When StrictlySimple and 'e' is being touched by another edge, then
					//make sure both edges have a vertex here ...
					if (strictlySimple)
					{
						Edge ePrev = e.prevInAEL;
						if (e.outIdx >= 0 && e.windDelta != 0 && ePrev != null && ePrev.outIdx >= 0 && ePrev
							.GetCurrent().GetX() == e.GetCurrent().GetX() && ePrev.windDelta != 0)
						{
							Point.LongPoint ip = new Point.LongPoint(e.GetCurrent());
							SetZ(ip, ePrev, e);
							Path.OutPt op = AddOutPt(ePrev, ip);
							Path.OutPt op2 = AddOutPt(e, ip);
							AddJoin(op, op2, ip);
						}
					}
					//StrictlySimple (type-3) join
					e = e.nextInAEL;
				}
			}
			//3. Process horizontals at the Top of the scanbeam ...
			ProcessHorizontals();
			maxima = null;
			//4. Promote intermediate vertices ...
			e = activeEdges;
			while (e != null)
			{
				if (e.IsIntermediate(topY))
				{
					Path.OutPt op = null;
					if (e.outIdx >= 0)
					{
						op = AddOutPt(e, e.GetTop());
					}
					Edge[] t = new Edge[] { e };
					UpdateEdgeIntoAEL(t);
					e = t[0];
					//if output polygons share an edge, they'll need joining later ...
					Edge ePrev = e.prevInAEL;
					Edge eNext = e.nextInAEL;
					if (ePrev != null && ePrev.GetCurrent().GetX() == e.GetBot().GetX() && ePrev.GetCurrent
						().GetY() == e.GetBot().GetY() && op != null && ePrev.outIdx >= 0 && ePrev.GetCurrent
						().GetY() > ePrev.GetTop().GetY() && Edge.SlopesEqual(e, ePrev, useFullRange) &&
						 e.windDelta != 0 && ePrev.windDelta != 0)
					{
						Path.OutPt op2 = AddOutPt(ePrev, e.GetBot());
						AddJoin(op, op2, e.GetTop());
					}
					else
					{
						if (eNext != null && eNext.GetCurrent().GetX() == e.GetBot().GetX() && eNext.GetCurrent
							().GetY() == e.GetBot().GetY() && op != null && eNext.outIdx >= 0 && eNext.GetCurrent
							().GetY() > eNext.GetTop().GetY() && Edge.SlopesEqual(e, eNext, useFullRange) &&
							 e.windDelta != 0 && eNext.windDelta != 0)
						{
							Path.OutPt op2 = AddOutPt(eNext, e.GetBot());
							AddJoin(op, op2, e.GetTop());
						}
					}
				}
				e = e.nextInAEL;
			}
			LOGGER.Exiting(typeof(DefaultClipper).GetName(), "processEdgesAtTopOfScanbeam");
		}

		private void ProcessHorizontal(Edge horzEdge)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "isHorizontal");
			IClipper.Direction[] dir = new IClipper.Direction[1];
			long[] horzLeft = new long[1];
			long[] horzRight = new long[1];
			bool IsOpen = horzEdge.outIdx >= 0 && polyOuts[horzEdge.outIdx].isOpen;
			GetHorzDirection(horzEdge, dir, horzLeft, horzRight);
			Edge eLastHorz = horzEdge;
			Edge eMaxPair = null;
			while (eLastHorz.nextInLML != null && eLastHorz.nextInLML.IsHorizontal())
			{
				eLastHorz = eLastHorz.nextInLML;
			}
			if (eLastHorz.nextInLML == null)
			{
				eMaxPair = eLastHorz.GetMaximaPair();
			}
			Path.Maxima currMax = maxima;
			if (currMax != null)
			{
				//get the first maxima in range (X) ...
				if (dir[0] == IClipper.Direction.LEFT_TO_RIGHT)
				{
					while (currMax != null && currMax.X <= horzEdge.GetBot().GetX())
					{
						currMax = currMax.Next;
					}
					if (currMax != null && currMax.X >= eLastHorz.GetBot().GetX())
					{
						currMax = null;
					}
				}
				else
				{
					while (currMax.Next != null && currMax.Next.X < horzEdge.GetBot().GetX())
					{
						currMax = currMax.Next;
					}
					if (currMax.X <= eLastHorz.GetTop().GetX())
					{
						currMax = null;
					}
				}
			}
			Path.OutPt op1 = null;
			for (; ; )
			{
				//loop through consec. horizontal edges
				bool IsLastHorz = horzEdge == eLastHorz;
				Edge e = horzEdge.GetNextInAEL(dir[0]);
				while (e != null)
				{
					//this code block inserts extra coords into horizontal edges (in output
					//polygons) whereever maxima touch these horizontal edges. This helps
					//'simplifying' polygons (ie if the Simplify property is set).
					if (currMax != null)
					{
						if (dir[0] == IClipper.Direction.LEFT_TO_RIGHT)
						{
							while (currMax != null && currMax.X < e.GetCurrent().GetX())
							{
								if (horzEdge.outIdx >= 0 && !IsOpen)
								{
									AddOutPt(horzEdge, new Point.LongPoint(currMax.X, horzEdge.GetBot().GetY()));
								}
								currMax = currMax.Next;
							}
						}
						else
						{
							while (currMax != null && currMax.X > e.GetCurrent().GetX())
							{
								if (horzEdge.outIdx >= 0 && !IsOpen)
								{
									AddOutPt(horzEdge, new Point.LongPoint(currMax.X, horzEdge.GetBot().GetY()));
								}
								currMax = currMax.Prev;
							}
						}
					}
					if (dir[0] == IClipper.Direction.LEFT_TO_RIGHT && e.GetCurrent().GetX() > horzRight
						[0] || dir[0] == IClipper.Direction.RIGHT_TO_LEFT && e.GetCurrent().GetX() < horzLeft
						[0])
					{
						break;
					}
					//Also break if we've got to the end of an intermediate horizontal edge ...
					//nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.
					if (e.GetCurrent().GetX() == horzEdge.GetTop().GetX() && horzEdge.nextInLML != null
						 && e.deltaX < horzEdge.nextInLML.deltaX)
					{
						break;
					}
					if (horzEdge.outIdx >= 0 && !IsOpen)
					{
						//note: may be done multiple times
						op1 = AddOutPt(horzEdge, e.GetCurrent());
						Edge eNextHorz = sortedEdges;
						while (eNextHorz != null)
						{
							if (eNextHorz.outIdx >= 0 && DoHorzSegmentsOverlap(horzEdge.GetBot().GetX(), horzEdge
								.GetTop().GetX(), eNextHorz.GetBot().GetX(), eNextHorz.GetTop().GetX()))
							{
								Path.OutPt op2 = GetLastOutPt(eNextHorz);
								AddJoin(op2, op1, eNextHorz.GetTop());
							}
							eNextHorz = eNextHorz.nextInSEL;
						}
						AddGhostJoin(op1, horzEdge.GetBot());
					}
					//OK, so far we're still in range of the horizontal Edge  but make sure
					//we're at the last of consec. horizontals when matching with eMaxPair
					if (e == eMaxPair && IsLastHorz)
					{
						if (horzEdge.outIdx >= 0)
						{
							AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.GetTop());
						}
						DeleteFromAEL(horzEdge);
						DeleteFromAEL(eMaxPair);
						return;
					}
					if (dir[0] == IClipper.Direction.LEFT_TO_RIGHT)
					{
						Point.LongPoint Pt = new Point.LongPoint(e.GetCurrent().GetX(), horzEdge.GetCurrent
							().GetY());
						IntersectEdges(horzEdge, e, Pt);
					}
					else
					{
						Point.LongPoint Pt = new Point.LongPoint(e.GetCurrent().GetX(), horzEdge.GetCurrent
							().GetY());
						IntersectEdges(e, horzEdge, Pt);
					}
					Edge eNext = e.GetNextInAEL(dir[0]);
					SwapPositionsInAEL(horzEdge, e);
					e = eNext;
				}
				//end while
				//Break out of loop if HorzEdge.NextInLML is not also horizontal ...
				if (horzEdge.nextInLML == null || !horzEdge.nextInLML.IsHorizontal())
				{
					break;
				}
				Edge[] temp = new Edge[1];
				temp[0] = horzEdge;
				UpdateEdgeIntoAEL(temp);
				horzEdge = temp[0];
				if (horzEdge.outIdx >= 0)
				{
					AddOutPt(horzEdge, horzEdge.GetBot());
				}
				GetHorzDirection(horzEdge, dir, horzLeft, horzRight);
			}
			//end for (;;)
			if (horzEdge.outIdx >= 0 && op1 == null)
			{
				op1 = GetLastOutPt(horzEdge);
				Edge eNextHorz = sortedEdges;
				while (eNextHorz != null)
				{
					if (eNextHorz.outIdx >= 0 && DoHorzSegmentsOverlap(horzEdge.GetBot().GetX(), horzEdge
						.GetTop().GetX(), eNextHorz.GetBot().GetX(), eNextHorz.GetTop().GetX()))
					{
						Path.OutPt op2 = GetLastOutPt(eNextHorz);
						AddJoin(op2, op1, eNextHorz.GetTop());
					}
					eNextHorz = eNextHorz.nextInSEL;
				}
				AddGhostJoin(op1, horzEdge.GetTop());
			}
			if (horzEdge.nextInLML != null)
			{
				if (horzEdge.outIdx >= 0)
				{
					op1 = AddOutPt(horzEdge, horzEdge.GetTop());
					Edge[] t = new Edge[] { horzEdge };
					UpdateEdgeIntoAEL(t);
					horzEdge = t[0];
					if (horzEdge.windDelta == 0)
					{
						return;
					}
					//nb: HorzEdge is no longer horizontal here
					Edge ePrev = horzEdge.prevInAEL;
					Edge eNext = horzEdge.nextInAEL;
					if (ePrev != null && ePrev.GetCurrent().GetX() == horzEdge.GetBot().GetX() && ePrev
						.GetCurrent().GetY() == horzEdge.GetBot().GetY() && ePrev.windDelta != 0 && ePrev
						.outIdx >= 0 && ePrev.GetCurrent().GetY() > ePrev.GetTop().GetY() && Edge.SlopesEqual
						(horzEdge, ePrev, useFullRange))
					{
						Path.OutPt op2 = AddOutPt(ePrev, horzEdge.GetBot());
						AddJoin(op1, op2, horzEdge.GetTop());
					}
					else
					{
						if (eNext != null && eNext.GetCurrent().GetX() == horzEdge.GetBot().GetX() && eNext
							.GetCurrent().GetY() == horzEdge.GetBot().GetY() && eNext.windDelta != 0 && eNext
							.outIdx >= 0 && eNext.GetCurrent().GetY() > eNext.GetTop().GetY() && Edge.SlopesEqual
							(horzEdge, eNext, useFullRange))
						{
							Path.OutPt op2 = AddOutPt(eNext, horzEdge.GetBot());
							AddJoin(op1, op2, horzEdge.GetTop());
						}
					}
				}
				else
				{
					Edge[] t = new Edge[] { horzEdge };
					UpdateEdgeIntoAEL(t);
					horzEdge = t[0];
				}
			}
			else
			{
				if (horzEdge.outIdx >= 0)
				{
					AddOutPt(horzEdge, horzEdge.GetTop());
				}
				DeleteFromAEL(horzEdge);
			}
		}

		//------------------------------------------------------------------------------
		private void ProcessHorizontals()
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "processHorizontals");
			Edge horzEdge = sortedEdges;
			while (horzEdge != null)
			{
				DeleteFromSEL(horzEdge);
				ProcessHorizontal(horzEdge);
				horzEdge = sortedEdges;
			}
		}

		//------------------------------------------------------------------------------
		private bool ProcessIntersections(long topY)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "processIntersections");
			if (activeEdges == null)
			{
				return true;
			}
			try
			{
				BuildIntersectList(topY);
				if (intersectList.Count == 0)
				{
					return true;
				}
				if (intersectList.Count == 1 || FixupIntersectionOrder())
				{
					ProcessIntersectList();
				}
				else
				{
					return false;
				}
			}
			catch (Exception e)
			{
				sortedEdges = null;
				intersectList.Clear();
				throw new InvalidOperationException("ProcessIntersections error", e);
			}
			sortedEdges = null;
			return true;
		}

		private void ProcessIntersectList()
		{
			for (int i = 0; i < intersectList.Count; i++)
			{
				DefaultClipper.IntersectNode iNode = intersectList[i];
				{
					IntersectEdges(iNode.edge1, iNode.Edge2, iNode.GetPt());
					SwapPositionsInAEL(iNode.edge1, iNode.Edge2);
				}
			}
			intersectList.Clear();
		}

		//------------------------------------------------------------------------------
		protected internal override void Reset()
		{
			base.Reset();
			scanbeam = null;
			maxima = null;
			activeEdges = null;
			sortedEdges = null;
			ClipperBase.LocalMinima lm = minimaList;
			while (lm != null)
			{
				InsertScanbeam(lm.y);
				lm = lm.next;
			}
		}

		private void SetHoleState(Edge e, Path.OutRec outRec)
		{
			bool isHole = false;
			Edge e2 = e.prevInAEL;
			while (e2 != null)
			{
				if (e2.outIdx >= 0 && e2.windDelta != 0)
				{
					isHole = !isHole;
					if (outRec.firstLeft == null)
					{
						outRec.firstLeft = polyOuts[e2.outIdx];
					}
				}
				e2 = e2.prevInAEL;
			}
			if (isHole)
			{
				outRec.isHole = true;
			}
		}

		private void SetZ(Point.LongPoint pt, Edge e1, Edge e2)
		{
			if (pt.GetZ() != 0 || zFillFunction == null)
			{
				return;
			}
			else
			{
				if (pt.Equals(e1.GetBot()))
				{
					pt.SetZ(e1.GetBot().GetZ());
				}
				else
				{
					if (pt.Equals(e1.GetTop()))
					{
						pt.SetZ(e1.GetTop().GetZ());
					}
					else
					{
						if (pt.Equals(e2.GetBot()))
						{
							pt.SetZ(e2.GetBot().GetZ());
						}
						else
						{
							if (pt.Equals(e2.GetTop()))
							{
								pt.SetZ(e2.GetTop().GetZ());
							}
							else
							{
								zFillFunction.ZFill(e1.GetBot(), e1.GetTop(), e2.GetBot(), e2.GetTop(), pt);
							}
						}
					}
				}
			}
		}

		private void SwapPositionsInAEL(Edge edge1, Edge edge2)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "swapPositionsInAEL");
			//check that one or other edge hasn't already been removed from AEL ...
			if (edge1.nextInAEL == edge1.prevInAEL || edge2.nextInAEL == edge2.prevInAEL)
			{
				return;
			}
			if (edge1.nextInAEL == edge2)
			{
				Edge next = edge2.nextInAEL;
				if (next != null)
				{
					next.prevInAEL = edge1;
				}
				Edge prev = edge1.prevInAEL;
				if (prev != null)
				{
					prev.nextInAEL = edge2;
				}
				edge2.prevInAEL = prev;
				edge2.nextInAEL = edge1;
				edge1.prevInAEL = edge2;
				edge1.nextInAEL = next;
			}
			else
			{
				if (edge2.nextInAEL == edge1)
				{
					Edge next = edge1.nextInAEL;
					if (next != null)
					{
						next.prevInAEL = edge2;
					}
					Edge prev = edge2.prevInAEL;
					if (prev != null)
					{
						prev.nextInAEL = edge1;
					}
					edge1.prevInAEL = prev;
					edge1.nextInAEL = edge2;
					edge2.prevInAEL = edge1;
					edge2.nextInAEL = next;
				}
				else
				{
					Edge next = edge1.nextInAEL;
					Edge prev = edge1.prevInAEL;
					edge1.nextInAEL = edge2.nextInAEL;
					if (edge1.nextInAEL != null)
					{
						edge1.nextInAEL.prevInAEL = edge1;
					}
					edge1.prevInAEL = edge2.prevInAEL;
					if (edge1.prevInAEL != null)
					{
						edge1.prevInAEL.nextInAEL = edge1;
					}
					edge2.nextInAEL = next;
					if (edge2.nextInAEL != null)
					{
						edge2.nextInAEL.prevInAEL = edge2;
					}
					edge2.prevInAEL = prev;
					if (edge2.prevInAEL != null)
					{
						edge2.prevInAEL.nextInAEL = edge2;
					}
				}
			}
			if (edge1.prevInAEL == null)
			{
				activeEdges = edge1;
			}
			else
			{
				if (edge2.prevInAEL == null)
				{
					activeEdges = edge2;
				}
			}
			LOGGER.Exiting(typeof(DefaultClipper).GetName(), "swapPositionsInAEL");
		}

		//------------------------------------------------------------------------------;
		private void SwapPositionsInSEL(Edge edge1, Edge edge2)
		{
			if (edge1.nextInSEL == null && edge1.prevInSEL == null)
			{
				return;
			}
			if (edge2.nextInSEL == null && edge2.prevInSEL == null)
			{
				return;
			}
			if (edge1.nextInSEL == edge2)
			{
				Edge next = edge2.nextInSEL;
				if (next != null)
				{
					next.prevInSEL = edge1;
				}
				Edge prev = edge1.prevInSEL;
				if (prev != null)
				{
					prev.nextInSEL = edge2;
				}
				edge2.prevInSEL = prev;
				edge2.nextInSEL = edge1;
				edge1.prevInSEL = edge2;
				edge1.nextInSEL = next;
			}
			else
			{
				if (edge2.nextInSEL == edge1)
				{
					Edge next = edge1.nextInSEL;
					if (next != null)
					{
						next.prevInSEL = edge2;
					}
					Edge prev = edge2.prevInSEL;
					if (prev != null)
					{
						prev.nextInSEL = edge1;
					}
					edge1.prevInSEL = prev;
					edge1.nextInSEL = edge2;
					edge2.prevInSEL = edge1;
					edge2.nextInSEL = next;
				}
				else
				{
					Edge next = edge1.nextInSEL;
					Edge prev = edge1.prevInSEL;
					edge1.nextInSEL = edge2.nextInSEL;
					if (edge1.nextInSEL != null)
					{
						edge1.nextInSEL.prevInSEL = edge1;
					}
					edge1.prevInSEL = edge2.prevInSEL;
					if (edge1.prevInSEL != null)
					{
						edge1.prevInSEL.nextInSEL = edge1;
					}
					edge2.nextInSEL = next;
					if (edge2.nextInSEL != null)
					{
						edge2.nextInSEL.prevInSEL = edge2;
					}
					edge2.prevInSEL = prev;
					if (edge2.prevInSEL != null)
					{
						edge2.prevInSEL.nextInSEL = edge2;
					}
				}
			}
			if (edge1.prevInSEL == null)
			{
				sortedEdges = edge1;
			}
			else
			{
				if (edge2.prevInSEL == null)
				{
					sortedEdges = edge2;
				}
			}
		}

		private void UpdateEdgeIntoAEL(Edge[] eV)
		{
			Edge e = eV[0];
			if (e.nextInLML == null)
			{
				throw new InvalidOperationException("UpdateEdgeIntoAEL: invalid call");
			}
			Edge AelPrev = e.prevInAEL;
			Edge AelNext = e.nextInAEL;
			e.nextInLML.outIdx = e.outIdx;
			if (AelPrev != null)
			{
				AelPrev.nextInAEL = e.nextInLML;
			}
			else
			{
				activeEdges = e.nextInLML;
			}
			if (AelNext != null)
			{
				AelNext.prevInAEL = e.nextInLML;
			}
			e.nextInLML.side = e.side;
			e.nextInLML.windDelta = e.windDelta;
			e.nextInLML.windCnt = e.windCnt;
			e.nextInLML.windCnt2 = e.windCnt2;
			eV[0] = e = e.nextInLML;
			e.SetCurrent(e.GetBot());
			e.prevInAEL = AelPrev;
			e.nextInAEL = AelNext;
			if (!e.IsHorizontal())
			{
				InsertScanbeam(e.GetTop().GetY());
			}
		}

		private void UpdateOutPtIdxs(Path.OutRec outrec)
		{
			Path.OutPt op = outrec.GetPoints();
			do
			{
				op.idx = outrec.Idx;
				op = op.prev;
			}
			while (op != outrec.GetPoints());
		}

		private void UpdateWindingCount(Edge edge)
		{
			LOGGER.Entering(typeof(DefaultClipper).GetName(), "updateWindingCount");
			Edge e = edge.prevInAEL;
			//find the edge of the same polytype that immediately preceeds 'edge' in AEL
			while (e != null && (e.polyTyp != edge.polyTyp || e.windDelta == 0))
			{
				e = e.prevInAEL;
			}
			if (e == null)
			{
				edge.windCnt = edge.windDelta == 0 ? 1 : edge.windDelta;
				edge.windCnt2 = 0;
				e = activeEdges;
			}
			else
			{
				//ie get ready to calc WindCnt2
				if (edge.windDelta == 0 && clipType != IClipper.ClipType.UNION)
				{
					edge.windCnt = 1;
					edge.windCnt2 = e.windCnt2;
					e = e.nextInAEL;
				}
				else
				{
					//ie get ready to calc WindCnt2
					if (edge.IsEvenOddFillType(clipFillType, subjFillType))
					{
						//EvenOdd filling ...
						if (edge.windDelta == 0)
						{
							//are we inside a subj polygon ...
							bool Inside = true;
							Edge e2 = e.prevInAEL;
							while (e2 != null)
							{
								if (e2.polyTyp == e.polyTyp && e2.windDelta != 0)
								{
									Inside = !Inside;
								}
								e2 = e2.prevInAEL;
							}
							edge.windCnt = Inside ? 0 : 1;
						}
						else
						{
							edge.windCnt = edge.windDelta;
						}
						edge.windCnt2 = e.windCnt2;
						e = e.nextInAEL;
					}
					else
					{
						//ie get ready to calc WindCnt2
						//nonZero, Positive or Negative filling ...
						if (e.windCnt * e.windDelta < 0)
						{
							//prev edge is 'decreasing' WindCount (WC) toward zero
							//so we're outside the previous polygon ...
							if (Math.Abs(e.windCnt) > 1)
							{
								//outside prev poly but still inside another.
								//when reversing direction of prev poly use the same WC
								if (e.windDelta * edge.windDelta < 0)
								{
									edge.windCnt = e.windCnt;
								}
								else
								{
									edge.windCnt = e.windCnt + edge.windDelta;
								}
							}
							else
							{
								//now outside all polys of same polytype so set own WC ...
								edge.windCnt = edge.windDelta == 0 ? 1 : edge.windDelta;
							}
						}
						else
						{
							//prev edge is 'increasing' WindCount (WC) away from zero
							//so we're inside the previous polygon ...
							if (edge.windDelta == 0)
							{
								edge.windCnt = e.windCnt < 0 ? e.windCnt - 1 : e.windCnt + 1;
							}
							else
							{
								if (e.windDelta * edge.windDelta < 0)
								{
									edge.windCnt = e.windCnt;
								}
								else
								{
									edge.windCnt = e.windCnt + edge.windDelta;
								}
							}
						}
						edge.windCnt2 = e.windCnt2;
						e = e.nextInAEL;
					}
				}
			}
			//ie get ready to calc WindCnt2
			//update WindCnt2 ...
			if (edge.IsEvenOddAltFillType(clipFillType, subjFillType))
			{
				//EvenOdd filling ...
				while (e != edge)
				{
					if (e.windDelta != 0)
					{
						edge.windCnt2 = edge.windCnt2 == 0 ? 1 : 0;
					}
					e = e.nextInAEL;
				}
			}
			else
			{
				//nonZero, Positive or Negative filling ...
				while (e != edge)
				{
					edge.windCnt2 += e.windDelta;
					e = e.nextInAEL;
				}
			}
		}
	}
}
